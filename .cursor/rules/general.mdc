---
description: "Elite Development Rules for Platform Médicos - World-class medical platform with HIPAA compliance and architectural excellence"
globs: ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx", "**/*.sql", "**/*.md", "**/*.json"]
alwaysApply: true
version: "2.0.0"
lastUpdated: "2025-09-20"
---

# 🏆 Reglas Elite de Desarrollo - Platform Médicos

> **CRÍTICO**: Plataforma médica de clase mundial que maneja datos sensibles de salud. Estas reglas garantizan excelencia arquitectónica, compliance HIPAA y escalabilidad empresarial.

## 🎯 Principios Fundamentales Elite

### 1. 🔒 Seguridad y Compliance Médico (NIVEL CRÍTICO)
- **HIPAA-Style Compliance**: Todos los datos médicos deben estar protegidos y auditados
- **Zero Trust**: Verificar permisos en cada operación, nunca confiar en datos del cliente
- **Data Minimization**: Solicitar y procesar solo datos estrictamente necesarios
- **Audit Trail**: Registrar todas las operaciones críticas para auditoría
- **Encryption**: Datos sensibles encriptados en tránsito y en reposo

```typescript
// ✅ Correcto - Verificación de permisos granular
const canAccessMedicalRecord = await checkPermissions(userId, recordId, 'read');
if (!canAccessMedicalRecord) {
  logSecurityEvent('unauthorized_access_attempt', { userId, recordId });
  throw new UnauthorizedError('Acceso denegado');
}
```

### 2. 🧬 Responsabilidad Única Extrema (SRP+)
- **Máximo 300 líneas por archivo** (regla estricta post-refactorización)
- **Una responsabilidad por módulo**: Cada archivo debe ser experto en UN solo aspecto
- **Separación granular**: UI, lógica, validación, tipos en archivos separados
- **Módulos cohesivos**: Alta cohesión interna, bajo acoplamiento externo
- **Refactorización automática**: Si un archivo supera 300 líneas, debe ser dividido inmediatamente

```typescript
// ✅ Correcto - Archivo con responsabilidad única
// src/components/medical/PatientVitalSigns.tsx (147 líneas)
interface PatientVitalSignsProps {
  patientId: string;
  readonly?: boolean;
}

const PatientVitalSigns = memo<PatientVitalSignsProps>(({ patientId, readonly }) => {
  // Solo maneja visualización de signos vitales
  // Validación en: src/lib/validations/vital-signs.validations.ts
  // Tipos en: src/types/medical/vital-signs.types.ts
  // Lógica en: src/hooks/medical/useVitalSigns.ts
});

// ❌ Incorrecto - Archivo con múltiples responsabilidades
// Un archivo que contenga: UI + validación + tipos + API calls + business logic
```

### 3. 🏛️ Arquitectura Limpia Estricta (Clean Architecture+)
- **Capas independientes**: Cada capa debe poder funcionar sin las superiores
- **Dependency Inversion radical**: Todas las dependencias apuntan hacia el dominio
- **Interfaces en lugar de implementaciones**: Nunca depender de concreciones
- **Testabilidad extrema**: Cada módulo debe ser 100% testeable en aislamiento

```typescript
// ✅ Arquitectura de capas estricta
src/
├── domains/              # 🏛️ Capa de Dominio (Business Logic)
│   ├── medical-records/  # Entidades y casos de uso médicos
│   ├── appointments/     # Lógica de citas médicas
│   └── compliance/       # Reglas de compliance
├── adapters/            # 🔌 Capa de Adaptadores (Infrastructure)
│   ├── supabase/       # Implementación específica de BD
│   ├── didit/          # Integración externa
│   └── email/          # Servicios de notificación
├── application/         # 🎯 Capa de Aplicación (Use Cases)
│   ├── services/       # Servicios de aplicación
│   └── ports/          # Interfaces (contratos)
└── presentation/        # 🎨 Capa de Presentación (UI)
    ├── components/     # Componentes React
    └── pages/         # Páginas Next.js
```

### 4. 🏗️ Arquitectura Escalable por Features
- **Domain-Driven Design**: Organizar código por dominio médico (auth, appointments, records, chat)
- **Bounded Contexts**: Cada feature es independiente y cohesiva
- **Clean Architecture**: Separación clara entre UI, business logic y data access
- **Vertical Slicing**: Features completas (UI + API + DB) en módulos independientes

### 5. 🔬 SOLID Principles para Medicina Digital
- **S** - Single Responsibility: Un módulo = Un experto médico
- **O** - Open/Closed: Extensible sin modificar (nuevas especialidades médicas)
- **L** - Liskov Substitution: Interfaces médicas intercambiables
- **I** - Interface Segregation: Interfaces específicas por rol médico
- **D** - Dependency Inversion: Depender de abstracciones médicas, no implementaciones

```typescript
// ✅ Ejemplo SOLID en medicina
interface MedicalRecordRepository {
  findByPatient(patientId: string): Promise<MedicalRecord[]>;
  create(record: MedicalRecordInput): Promise<MedicalRecord>;
}

// Implementación específica (puede cambiar sin afectar dominio)
class SupabaseMedicalRecordRepository implements MedicalRecordRepository {
  async findByPatient(patientId: string): Promise<MedicalRecord[]> {
    // Implementación específica de Supabase
  }
}

// Servicio de dominio (estable, no cambia)
class MedicalRecordService {
  constructor(private repository: MedicalRecordRepository) {} // DI
  
  async createRecord(data: MedicalRecordInput): Promise<MedicalRecord> {
    // Lógica de negocio pura
    await this.validateMedicalData(data);
    return this.repository.create(data);
  }
}
```

### 6. ⚡ Performance y Escalabilidad Elite
- **Lazy Loading Inteligente**: Cargar módulos médicos solo cuando sean necesarios
- **Memoización Selectiva**: Solo memoizar componentes costosos de renderizar
- **Optimistic Updates**: Para mejorar UX en operaciones médicas no críticas
- **Cache Strategies**: Cache inteligente para datos médicos frecuentes
- **Code Splitting**: Por roles médicos y especialidades

```typescript
// ✅ Performance elite para aplicaciones médicas
const DoctorDashboard = lazy(() => 
  import('@/features/doctor/DoctorDashboard').then(module => ({
    default: memo(module.default, (prev, next) => 
      prev.doctorId === next.doctorId && 
      prev.lastUpdateTime === next.lastUpdateTime
    )
  }))
);

// ✅ Cache estratégico para datos médicos
const usePatientHistory = (patientId: string) => {
  return useQuery({
    queryKey: ['patient-history', patientId],
    queryFn: () => fetchPatientHistory(patientId),
    staleTime: 5 * 60 * 1000, // 5 min para datos médicos críticos
    cacheTime: 30 * 60 * 1000, // 30 min en cache
    retry: 3,
    retryDelay: attemptIndex => Math.min(1000 * 2 ** attemptIndex, 30000),
  });
};
```

### 7. 🧪 Testing de Clase Mundial
- **Testing Pyramid**: 70% Unit, 20% Integration, 10% E2E
- **Medical Critical Path Testing**: 100% coverage en flujos médicos críticos
- **Property-Based Testing**: Para validaciones médicas complejas
- **Snapshot Testing**: Para componentes médicos estables
- **Performance Testing**: Para operaciones en tiempo real

```typescript
// ✅ Testing elite para medicina
describe('MedicalRecordCreation', () => {
  it('should validate all medical data before persistence', async () => {
    // Arrange
    const invalidRecord = createInvalidMedicalRecord();
    const validRecord = createValidMedicalRecord();
    
    // Act & Assert
    await expect(createMedicalRecord(invalidRecord)).rejects.toThrow('Validation failed');
    
    const result = await createMedicalRecord(validRecord);
    expect(result.id).toMatch(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/);
    
    // Security assertion
    expect(auditLogger.logMedicalEvent).toHaveBeenCalledWith(
      expect.objectContaining({
        eventType: 'medical_record_created',
        severity: 'info',
        patientId: validRecord.patientId
      })
    );
  });
  
  // Property-based testing para validaciones médicas
  it('should handle all valid blood pressure combinations', () => {
    fc.assert(fc.property(
      fc.integer({ min: 80, max: 200 }), // systolic
      fc.integer({ min: 40, max: 120 }), // diastolic
      (systolic, diastolic) => {
        fc.pre(systolic > diastolic); // precondition
        const vitalSigns = { systolic, diastolic };
        expect(validateVitalSigns(vitalSigns)).toBe(true);
      }
    ));
  });
});
```

## 🏗️ Estructura de Archivos Elite (Arquitectura Multi-Rol)

### Organización Elite por Dominios Médicos (Post-Refactorización)
```
src/
├── app/                       # 🚀 Next.js 15 App Router
│   ├── (auth)/               # 🔐 Autenticación y verificación
│   ├── (protected)/          # 🛡️ Rutas protegidas con múltiples roles
│   ├── doctor/               # 👨‍⚕️ Dashboard y funciones para médicos
│   ├── patient/              # 👤 Portal y dashboard para pacientes
│   ├── clinic/               # 🏥 Gestión para clínicas
│   ├── laboratory/           # 🔬 Gestión para laboratorios (refactorizado)
│   ├── admin/                # ⚙️ Administración del sistema
│   ├── emergency/            # 🚨 Protocolo de emergencias médicas
│   └── api/                  # 📡 API endpoints con RLS
│
├── components/               # 🧩 Componentes Modulares por Dominio
│   ├── auth/                # 🔑 Autenticación (refactorizado)
│   │   ├── shared/          # ✅ Componentes compartidos
│   │   ├── patient/         # ✅ Específicos de pacientes
│   │   ├── verification/    # ✅ Verificación de identidad
│   │   └── doctor-registration/ # ✅ Registro médico especializado
│   ├── laboratory/          # 🔬 Laboratorio (refactorizado)
│   │   ├── LabStatisticsWidget.tsx    # ✅ (142 líneas)
│   │   ├── LabFilters.tsx             # ✅ (98 líneas)
│   │   ├── LabTestsTable.tsx          # ⚠️ (465 líneas - revisar)
│   │   └── LabWidgets.tsx             # ⚠️ (454 líneas - revisar)
│   ├── dashboard/           # 📊 Dashboards especializados
│   ├── patient-dashboard/   # 👤 Dashboard específico de pacientes
│   ├── ui/                  # 🎨 Design System médico (Shadcn/ui)
│   └── navigation/          # 🧭 Navegación multi-rol
│
├── domains/                 # 🏛️ Lógica de Dominio Médico (DDD)
│   ├── auth/               # 🔐 Autenticación y registro
│   │   ├── components/     # Componentes específicos del dominio
│   │   ├── hooks/          # Hooks especializados
│   │   ├── services/       # Servicios de negocio
│   │   ├── types/          # Tipos del dominio
│   │   └── utils/          # Utilidades del dominio
│   ├── compliance/         # 📋 Verificación y compliance HIPAA
│   │   ├── hooks/useDiditVerification.ts  # ⚠️ (499 líneas - revisar)
│   │   ├── services/       # Servicios de verificación
│   │   └── types/          # Tipos de compliance
│   ├── medical-records/    # 📋 Historiales médicos
│   ├── appointments/       # 📅 Gestión de citas médicas
│   └── emergency/          # 🚨 Servicios de emergencia
│
├── lib/                    # 🛠️ Configuraciones y Utilidades
│   ├── validations/        # ✅ Validaciones modulares (refactorizado)
│   │   ├── personal-info.validations.ts      # ✅ (89 líneas)
│   │   ├── professional-info.validations.ts  # ✅ (156 líneas)
│   │   ├── specialty.validations.ts          # ✅ (67 líneas)
│   │   ├── license-verification.validations.ts # ✅ (134 líneas)
│   │   ├── identity-verification.validations.ts # ✅ (387 líneas)
│   │   ├── dashboard-config.validations.ts   # ⚠️ (501 líneas - revisar)
│   │   ├── security.validations.ts           # ✅ (466 líneas)
│   │   └── index.ts                          # ✅ Re-exportación central
│   ├── medical-specialties/ # ✅ Especialidades modulares (refactorizado)
│   │   ├── base-features.ts                  # ✅ (407 líneas)
│   │   ├── specialties-data.ts               # Datos de especialidades
│   │   ├── utils.ts                          # Utilidades
│   │   └── index.ts                          # Re-exportación
│   ├── license-validator/   # ✅ Validador modular (refactorizado)
│   │   ├── config.ts                         # ✅ (95 líneas)
│   │   ├── browser-service.ts                # ✅ (494 líneas)
│   │   ├── sacs-scraper.ts                   # Scraping SACS
│   │   ├── mpps-fallback.ts                  # Fallback MPPS
│   │   └── index.ts                          # Re-exportación
│   ├── laboratory/         # ✅ Utilidades de laboratorio (nuevo)
│   │   └── lab-utils.ts                      # ✅ (427 líneas)
│   ├── supabase/          # 🗄️ Cliente Supabase con RLS
│   └── logging/           # 📝 Logging estructurado para auditoría
│
├── types/                  # 📝 Tipos TypeScript Modulares (refactorizado)
│   ├── database/          # ✅ Tipos por dominio médico (refactorizado)
│   │   ├── auth.types.ts                     # ✅ (78 líneas)
│   │   ├── patients.types.ts                 # ✅ (156 líneas)
│   │   ├── doctors.types.ts                  # ✅ (89 líneas)
│   │   ├── appointments.types.ts             # ✅ (67 líneas)
│   │   ├── medical-records.types.ts          # ✅ (98 líneas)
│   │   ├── clinics.types.ts                  # ✅ (76 líneas)
│   │   ├── laboratory.types.ts               # ✅ (134 líneas)
│   │   ├── notifications.types.ts            # ✅ (45 líneas)
│   │   ├── health.types.ts                   # ✅ (408 líneas)
│   │   ├── base.types.ts                     # ✅ (34 líneas)
│   │   └── index.ts                          # ✅ Exportación unificada
│   ├── medical-specialties/ # ✅ Tipos de especialidades (nuevo)
│   │   └── medical-specialties.types.ts     # ✅ (89 líneas)
│   ├── laboratory/        # ✅ Tipos de laboratorio (nuevo)
│   │   └── laboratory.types.ts              # ✅ (67 líneas)
│   ├── auth/              # Tipos de autenticación
│   ├── dashboard/         # Tipos de dashboards
│   └── shared/            # Tipos compartidos
│
├── hooks/                 # 🎣 Custom Hooks Especializados
│   ├── laboratory/        # ✅ Hooks de laboratorio (nuevo)
│   │   └── useLabData.ts                     # ✅ (156 líneas)
│   ├── medical/           # Hooks médicos específicos
│   └── auth/              # Hooks de autenticación
│
├── providers/             # 🔗 Context Providers Especializados
├── adapters/              # 🔌 Adaptadores para servicios externos
├── test/                  # 🧪 Suite de testing automatizado
└── middleware.ts          # 🛡️ Middleware de protección de rutas
```

### ✅ Métricas Post-Refactorización
- **7 archivos principales refactorizados** → 40+ módulos especializados
- **Responsabilidad única**: 100% en archivos refactorizados
- **26 archivos > 400 líneas** → Candidatos para próxima iteración
- **0 código duplicado** significativo detectado
- **Backward compatibility** mantenida con archivos deprecated

### Convenciones de Nomenclatura Médica Elite
- **Componentes**: PascalCase con sufijo de dominio (`MedicalRecordForm.tsx`, `EmergencyContactsList.tsx`)
- **Hooks**: camelCase médico específico (`useMedicalHistory.ts`, `useEmergencyContacts.ts`)
- **Servicios**: PascalCase + Service (`MedicalRecordService.ts`, `ComplianceValidationService.ts`)
- **Repositorios**: PascalCase + Repository (`PatientRepository.ts`, `AppointmentRepository.ts`)
- **Utilidades**: camelCase descriptivo (`validateMedicalID.ts`, `formatDiagnosis.ts`)
- **Tipos**: PascalCase + Types (`Patient.types.ts`, `MedicalRecord.types.ts`)
- **Validaciones**: kebab-case + .validations (`medical-record.validations.ts`)
- **Constantes médicas**: UPPER_SNAKE_CASE (`MEDICAL_SPECIALTIES.ts`, `EMERGENCY_PROTOCOLS.ts`)
- **Rutas**: kebab-case (`patient-dashboard/`, `emergency-contacts/`)
- **Test files**: `.test.ts` o `.spec.ts` (`PatientService.test.ts`)

### 🔧 Reglas de Refactorización Continua
- **Threshold automático**: Archivo > 300 líneas → Refactorizar inmediatamente
- **Complejidad ciclomática**: Función > 10 → Dividir en subfunciones
- **Dependencias por archivo**: > 15 imports → Revisar acoplamiento
- **Duplicate code**: > 3 líneas repetidas → Extraer a utilidad común
- **Performance degradation**: > 100ms render → Optimizar o memoizar

```typescript
// ✅ Trigger automático de refactorización
// Pre-commit hook que verifica métricas de calidad
const qualityGates = {
  maxLinesPerFile: 300,
  maxComplexity: 10,
  maxImports: 15,
  minTestCoverage: 80,
  maxRenderTime: 100 // ms
};

// Script automatizado para detección
function analyzeFileQuality(filePath: string): QualityReport {
  const analysis = {
    lineCount: getLineCount(filePath),
    complexity: getCyclomaticComplexity(filePath),
    importCount: getImportCount(filePath),
    duplicateCode: findDuplicateCode(filePath),
    testCoverage: getTestCoverage(filePath)
  };
  
  const violations = [];
  if (analysis.lineCount > qualityGates.maxLinesPerFile) {
    violations.push(`File exceeds ${qualityGates.maxLinesPerFile} lines`);
  }
  
  return { analysis, violations, requiresRefactoring: violations.length > 0 };
}
```

## 📝 Reglas de Código TypeScript Elite

### TypeScript para Datos Médicos (Nivel Avanzado)
- **Tipos explícitos obligatorios**: Todos los datos médicos deben estar tipados
- **Strict mode extremo**: `"strict": true` + `"noUncheckedIndexedAccess": true`
- **No usar `any` JAMÁS**: Usar tipos específicos o `unknown` para datos médicos
- **Branded Types**: Para IDs médicos únicos y validados
- **Union types discriminados**: Para estados médicos complejos
- **Zod para validación runtime**: Validar datos médicos en runtime con schemas específicos
- **Template Literal Types**: Para IDs con formato específico
- **Utility Types**: Para transformaciones seguras de tipos

```typescript
// ✅ Branded Types para seguridad médica
type PatientId = string & { __brand: 'PatientId' };
type DoctorId = string & { __brand: 'DoctorId' };
type MedicalRecordId = string & { __brand: 'MedicalRecordId' };

// ✅ Funciones de construcción segura
const createPatientId = (id: string): PatientId => {
  if (!id.match(/^PAT-[0-9A-F]{8}$/)) {
    throw new Error('Invalid patient ID format');
  }
  return id as PatientId;
};

// ✅ Union types discriminados para estados médicos
type MedicalRecordStatus = 
  | { status: 'draft'; lastModified: Date; canEdit: true }
  | { status: 'reviewed'; reviewedBy: DoctorId; reviewDate: Date; canEdit: false }
  | { status: 'archived'; archivedBy: DoctorId; archiveDate: Date; canEdit: false }
  | { status: 'deleted'; deletedBy: DoctorId; deleteDate: Date; canEdit: false };

// ✅ Template Literal Types para IDs con formato
type VenezuelanCedula = `V-${number}` | `E-${number}`;
type MedicalLicense = `MPPS-${number}`;
type EmergencyCode = `EMR-${number}-${number}`;

// ✅ Utility Types para transformaciones médicas
type MedicalRecordInput = Omit<MedicalRecord, 'id' | 'createdAt' | 'updatedAt'>;
type PatientSummary = Pick<Patient, 'id' | 'firstName' | 'lastName' | 'dateOfBirth'>;
type PartialMedicalUpdate = Partial<Pick<MedicalRecord, 'diagnosis' | 'treatment' | 'notes'>>;

// ✅ Conditional types para permisos médicos
type MedicalAccess<T extends UserRole> = 
  T extends 'doctor' ? FullMedicalAccess :
  T extends 'nurse' ? LimitedMedicalAccess :
  T extends 'patient' ? OwnDataAccess :
  NoAccess;
```

### Validaciones Zod Avanzadas para Medicina
```typescript
// ✅ Schemas médicos con validaciones complejas
const VitalSignsSchema = z.object({
  bloodPressure: z.object({
    systolic: z.number().min(70).max(250),
    diastolic: z.number().min(40).max(150)
  }).refine(
    data => data.systolic > data.diastolic,
    { message: "Presión sistólica debe ser mayor que diastólica" }
  ),
  heartRate: z.number().min(30).max(220),
  temperature: z.number().min(35).max(42),
  oxygenSaturation: z.number().min(80).max(100),
  timestamp: z.date().max(new Date(), "No puede ser fecha futura")
});

// ✅ Schema con transformaciones automáticas
const PatientRegistrationSchema = z.object({
  cedula: z.string()
    .regex(/^[VE]-\d{7,8}$/, "Formato de cédula inválido")
    .transform(val => val.toUpperCase() as VenezuelanCedula),
  email: z.string().email().transform(val => val.toLowerCase()),
  phone: z.string()
    .regex(/^\+58\d{10}$/, "Teléfono venezolano inválido")
    .transform(val => val.replace(/\D/g, '')),
  emergencyContacts: z.array(EmergencyContactSchema).min(1).max(3)
});

// ✅ Validación condicional basada en rol médico
const MedicalRecordCreationSchema = z.object({
  patientId: z.string().uuid(),
  diagnosis: z.string().min(10).max(1000),
  treatment: z.string().min(5).max(2000),
  medications: z.array(MedicationSchema).default([]),
  confidentialityLevel: z.enum(['public', 'restricted', 'confidential', 'secret']),
  createdByRole: z.enum(['doctor', 'nurse', 'specialist'])
}).refine(
  data => {
    // Solo médicos pueden crear registros confidenciales
    if (data.confidentialityLevel === 'confidential' && data.createdByRole !== 'doctor') {
      return false;
    }
    return true;
  },
  { message: "Solo médicos pueden crear registros confidenciales" }
);
```

### Componentes React Elite para Interfaces Médicas
- **Functional components únicamente**: No class components JAMÁS
- **Props inmutables estrictas**: Usar `readonly` en todas las props médicas
- **Memoización inteligente**: Comparadores personalizados para datos médicos
- **Error boundaries obligatorios**: Capturar errores en interfaces críticas
- **Accessibility compliance**: WCAG 2.1 AA para interfaces médicas
- **Compound Components**: Para interfaces médicas complejas
- **Render Props**: Para lógica reutilizable médica
- **Hooks personalizados**: Para lógica específica del dominio médico

```typescript
// ✅ Componente médico elite con todas las mejores prácticas
import { memo, useCallback, useEffect, useMemo, forwardRef } from 'react';
import { logSecurityEvent } from '@/lib/security/auditLogger';
import { useMedicalRecordPermissions } from '@/hooks/medical/useMedicalRecordPermissions';
import { ErrorBoundary } from '@/components/error-boundary/MedicalErrorBoundary';
import type { MedicalRecord, SecurityEvent, UserRole } from '@/types/medical';

// ✅ Props inmutables con readonly
interface MedicalRecordViewProps {
  readonly record: MedicalRecord;
  readonly userRole: UserRole;
  readonly canEdit: boolean;
  readonly isEmergencyAccess?: boolean;
  readonly onUpdate: (record: Partial<MedicalRecord>) => Promise<void>;
  readonly onSecurityEvent: (event: SecurityEvent) => void;
  readonly className?: string;
}

// ✅ Comparador personalizado para memoización inteligente
const arePropsEqual = (
  prevProps: MedicalRecordViewProps,
  nextProps: MedicalRecordViewProps
): boolean => {
  return (
    prevProps.record.id === nextProps.record.id &&
    prevProps.record.updatedAt === nextProps.record.updatedAt &&
    prevProps.canEdit === nextProps.canEdit &&
    prevProps.userRole === nextProps.userRole &&
    prevProps.isEmergencyAccess === nextProps.isEmergencyAccess
  );
};

// ✅ Componente con forwardRef para accesibilidad
const MedicalRecordView = memo(forwardRef<HTMLDivElement, MedicalRecordViewProps>(({ 
  record, 
  userRole,
  canEdit, 
  isEmergencyAccess = false,
  onUpdate, 
  onSecurityEvent,
  className = ''
}, ref) => {
  // ✅ Hook personalizado para permisos médicos
  const { canViewSensitiveData, canEditRecord, permissions } = useMedicalRecordPermissions({
    userRole,
    recordConfidentiality: record.confidentialityLevel,
    isEmergencyAccess
  });

  // ✅ Audit trail automático con cleanup
  useEffect(() => {
    const viewEvent = {
      eventType: 'medical_record_viewed' as const,
      recordId: record.id,
      patientId: record.patientId,
      userRole,
      isEmergencyAccess,
      confidentialityLevel: record.confidentialityLevel,
      timestamp: new Date().toISOString()
    };

    logSecurityEvent(viewEvent);

    // Cleanup: registrar tiempo de visualización
    return () => {
      logSecurityEvent({
        eventType: 'medical_record_view_ended',
        recordId: record.id,
        sessionDuration: Date.now() - new Date(viewEvent.timestamp).getTime()
      });
    };
  }, [record.id, record.patientId, userRole, isEmergencyAccess, record.confidentialityLevel]);

  // ✅ Handler optimizado con validaciones de seguridad
  const handleUpdate = useCallback(async (updates: Partial<MedicalRecord>) => {
    if (!canEditRecord) {
      onSecurityEvent({ 
        type: 'unauthorized_edit_attempt', 
        recordId: record.id,
        userRole 
      });
      return;
    }

    try {
      await onUpdate(updates);
      logSecurityEvent({
        eventType: 'medical_record_updated',
        recordId: record.id,
        updatedFields: Object.keys(updates),
        userRole
      });
    } catch (error) {
      onSecurityEvent({ 
        type: 'update_failed', 
        error, 
        recordId: record.id 
      });
    }
  }, [record.id, canEditRecord, onUpdate, onSecurityEvent, userRole]);

  // ✅ Datos computados con memoización
  const displayData = useMemo(() => {
    if (!canViewSensitiveData) {
      return {
        ...record,
        diagnosis: '[CONFIDENCIAL]',
        treatment: '[CONFIDENCIAL]',
        notes: '[CONFIDENCIAL]'
      };
    }
    return record;
  }, [record, canViewSensitiveData]);

  // ✅ Render con accesibilidad completa
  return (
    <ErrorBoundary fallback={<MedicalRecordErrorFallback />}>
      <div 
        ref={ref}
        className={`medical-record-view ${className}`}
        role="region" 
        aria-label={`Registro médico de ${record.patientName}`}
        aria-describedby={`record-${record.id}-description`}
        data-testid={`medical-record-${record.id}`}
      >
        <div id={`record-${record.id}-description`} className="sr-only">
          Registro médico creado el {new Date(record.createdAt).toLocaleDateString()}
          {isEmergencyAccess && ' - Acceso de emergencia activo'}
        </div>
        
        {/* Contenido del componente con datos filtrados */}
        <MedicalRecordContent 
          record={displayData}
          permissions={permissions}
          onUpdate={canEdit ? handleUpdate : undefined}
        />
      </div>
    </ErrorBoundary>
  );
}), arePropsEqual);

MedicalRecordView.displayName = 'MedicalRecordView';

// ✅ Compound component para funcionalidad específica
MedicalRecordView.Header = MedicalRecordHeader;
MedicalRecordView.Content = MedicalRecordContent;
MedicalRecordView.Actions = MedicalRecordActions;

export default MedicalRecordView;
```

## 🚀 CI/CD y Deployment Elite

### Pipeline de Calidad Médica
- **Multi-stage pipeline**: dev → staging → production con gates de calidad
- **Automated quality gates**: Tests, security scans, performance checks
- **Medical compliance checks**: HIPAA validation automática
- **Zero-downtime deployment**: Para servicios médicos críticos
- **Rollback automático**: En caso de degradación de performance

```yaml
# ✅ Pipeline de calidad médica
name: Medical Platform CI/CD

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  quality-gates:
    runs-on: ubuntu-latest
    steps:
      - name: Code Quality Check
        run: |
          # Verificar límite de líneas por archivo
          find src -name "*.ts" -o -name "*.tsx" | xargs wc -l | awk '$1 > 300 {print "File " $2 " exceeds 300 lines: " $1; exit 1}'
          
          # Verificar responsabilidad única
          npm run analyze:responsibilities
          
          # Security scan para datos médicos
          npm run security:medical-scan
          
      - name: Medical Compliance Check
        run: |
          # Verificar audit trail
          npm run compliance:audit-trail-check
          
          # Validar RLS policies
          npm run db:validate-rls
          
          # Check HIPAA compliance
          npm run compliance:hipaa-check

  performance-testing:
    needs: quality-gates
    runs-on: ubuntu-latest
    steps:
      - name: Load Testing Medical APIs
        run: |
          # Test performance de endpoints críticos
          npm run test:performance:medical
          
          # Database performance check
          npm run test:db-performance
          
          # Real-time systems test
          npm run test:realtime-performance

  security-testing:
    needs: quality-gates
    runs-on: ubuntu-latest
    steps:
      - name: Security Penetration Testing
        run: |
          # Test de penetración automatizado
          npm run security:penetration-test
          
          # Vulnerability scan
          npm audit --audit-level high
          
          # Medical data encryption check
          npm run security:encryption-check
```

### Métricas de Calidad Continua
```typescript
// ✅ Métricas automáticas de calidad
interface QualityMetrics {
  codeQuality: {
    averageLinesPerFile: number;
    filesExceedingLimit: number;
    duplicateCodePercentage: number;
    cyclomaticComplexity: number;
  };
  testCoverage: {
    statements: number;
    branches: number;
    functions: number;
    lines: number;
    criticalPathsCovered: number;
  };
  performance: {
    averageApiResponseTime: number;
    p95ResponseTime: number;
    errorRate: number;
    uptime: number;
  };
  security: {
    vulnerabilitiesCount: number;
    lastSecurityScan: Date;
    complianceScore: number;
    auditTrailCoverage: number;
  };
}

// ✅ Dashboard de métricas automático
class QualityDashboard {
  async generateReport(): Promise<QualityMetrics> {
    return {
      codeQuality: await this.analyzeCodeQuality(),
      testCoverage: await this.analyzeTestCoverage(),
      performance: await this.analyzePerformance(),
      security: await this.analyzeSecurityPosture()
    };
  }
  
  async checkQualityGates(metrics: QualityMetrics): Promise<boolean> {
    const gates = [
      metrics.codeQuality.averageLinesPerFile < 250,
      metrics.testCoverage.criticalPathsCovered === 100,
      metrics.performance.p95ResponseTime < 500,
      metrics.security.vulnerabilitiesCount === 0
    ];
    
    return gates.every(gate => gate);
  }
}
```

## 🔐 Autenticación y Seguridad Multi-Rol Elite

### Supabase Auth con RLS Granular
- **Row Level Security obligatorio**: Todas las tablas médicas con RLS
- **Políticas granulares**: Verificar permisos específicos por rol y contexto
- **Functions con SECURITY DEFINER**: Funciones de BD con search_path fijo
- **Rate limiting**: Protección contra ataques de fuerza bruta
- **Session recovery**: Manejo robusto de sesiones expiradas

```typescript
// ✅ Verificación de permisos granular
const hasAccess = await supabase.rpc('check_medical_record_access', {
  p_user_id: user.id,
  p_record_id: recordId,
  p_action: 'read',
  p_context: 'emergency' // contexto adicional para emergencias
});

// ✅ Políticas RLS específicas por rol
-- En migration SQL
CREATE POLICY "doctors_read_patients" ON medical_records
  FOR SELECT USING (
    auth.role() = 'doctor' AND 
    doctor_id = auth.uid() OR
    EXISTS (
      SELECT 1 FROM appointments 
      WHERE patient_id = medical_records.patient_id 
      AND doctor_id = auth.uid()
      AND status = 'active'
    )
  );
```

### Protección de Rutas Multi-Nivel
- **Middleware de Next.js**: Primera línea de defensa
- **AuthGuard components**: Verificación granular en componentes
- **Role-based access**: Verificar roles específicos por contexto
- **Emergency access**: Protocolos especiales para emergencias médicas

```typescript
// ✅ Middleware con protección multi-rol
export async function middleware(request: NextRequest) {
  const { session, role } = await verifySession(request);
  
  if (!session) {
    return redirectToLogin(request);
  }

  // Verificación específica por ruta médica
  if (request.nextUrl.pathname.startsWith('/doctor/')) {
    if (role !== 'doctor') {
      logSecurityEvent('unauthorized_doctor_access', { 
        userId: session.user.id, 
        attemptedPath: request.nextUrl.pathname 
      });
      return NextResponse.redirect(new URL('/auth/unauthorized', request.url));
    }
  }

  // Protección especial para datos críticos
  if (request.nextUrl.pathname.includes('/emergency/')) {
    const hasEmergencyAccess = await verifyEmergencyAccess(session.user.id);
    if (!hasEmergencyAccess) {
      return NextResponse.redirect(new URL('/auth/insufficient-privileges', request.url));
    }
  }

  return NextResponse.next();
}
```

## 🎨 UI/UX para Interfaces Médicas

### Tailwind CSS con Design System Médico
- **Accessibility-first**: WCAG 2.1 AA compliance obligatorio
- **Color coding médico**: Colores específicos para urgencias, warnings, success
- **High contrast**: Garantizar legibilidad en entornos médicos
- **Mobile-first responsive**: Diseño para dispositivos médicos diversos

### Componentes UI Especializados
- **Radix UI**: Base accesible para componentes complejos
- **Shadcn/ui**: Design system consistente adaptado al dominio médico
- **Loading states**: Estados de carga para operaciones críticas
- **Error states**: Manejo de errores user-friendly pero informativo

```typescript
// ✅ Componente con variants médicos
const alertVariants = cva(
  "border px-4 py-3 rounded-md",
  {
    variants: {
      variant: {
        emergency: "bg-red-50 border-red-200 text-red-800",
        warning: "bg-yellow-50 border-yellow-200 text-yellow-800",
        success: "bg-green-50 border-green-200 text-green-800",
        info: "bg-blue-50 border-blue-200 text-blue-800",
        critical: "bg-red-100 border-red-300 text-red-900 animate-pulse"
      },
      urgency: {
        low: "",
        medium: "border-2",
        high: "border-4 shadow-lg",
        critical: "border-4 shadow-xl animate-bounce"
      }
    }
  }
);
```

## 📊 Manejo de Datos Médicos

### React Query para Estado del Servidor Médico
- **Invalidación inteligente**: Cache invalidation para datos críticos
- **Background updates**: Actualizaciones en tiempo real para datos vitales
- **Error retry logic**: Reintentos específicos para operaciones médicas
- **Optimistic updates**: Solo para operaciones no críticas

```typescript
// ✅ Query médica con invalidación automática
const { data: medicalRecords, isLoading, error } = useQuery({
  queryKey: ['medicalRecords', patientId, { includeEmergency: true }],
  queryFn: async () => {
    const { data, error } = await supabase
      .from('medical_records')
      .select(`
        *,
        medications (*),
        allergies (*),
        emergency_contacts (*)
      `)
      .eq('patient_id', patientId)
      .order('created_at', { ascending: false });
    
    if (error) {
      logSecurityEvent('medical_record_access_error', { patientId, error });
      throw error;
    }
    
    return data;
  },
  staleTime: 5 * 60 * 1000, // 5 minutos para datos médicos
  refetchInterval: 30 * 1000, // Actualizar cada 30 segundos
  refetchOnWindowFocus: true, // Crítico para datos médicos actualizados
});

// ✅ Mutation con audit trail
const updateMedicalRecord = useMutation({
  mutationFn: async (updates: Partial<MedicalRecord>) => {
    const { data, error } = await supabase
      .from('medical_records')
      .update({
        ...updates,
        last_modified: new Date().toISOString(),
        last_modified_by: user.id
      })
      .eq('id', recordId)
      .select();
      
    if (error) throw error;
    return data;
  },
  onSuccess: () => {
    // Invalidar queries relacionadas
    queryClient.invalidateQueries(['medicalRecords', patientId]);
    queryClient.invalidateQueries(['patientSummary', patientId]);
    
    logSecurityEvent('medical_record_updated', {
      recordId,
      patientId,
      updatedBy: user.id
    });
  },
  onError: (error) => {
    logSecurityEvent('medical_record_update_failed', {
      recordId,
      patientId,
      error: error.message
    });
  }
});
```

### Zustand para Estado Global Médico
- **Estado mínimo**: Solo datos críticos compartidos
- **Persistence selectiva**: Solo datos no sensibles en localStorage
- **State splitting**: Separar estado por dominio médico
- **Security boundaries**: No almacenar datos médicos sensibles

```typescript
// ✅ Store médico seguro
interface MedicalAppState {
  currentPatient: { id: string; name: string } | null; // Solo datos básicos
  activeEmergency: boolean;
  notifications: MedicalNotification[];
  userPreferences: UserPreferences;
}

const useMedicalStore = create<MedicalAppState>()(
  devtools(
    persist(
      (set, get) => ({
        currentPatient: null,
        activeEmergency: false,
        notifications: [],
        userPreferences: {},
        
        setCurrentPatient: (patient) => {
          logSecurityEvent('patient_context_changed', { 
            previousPatient: get().currentPatient?.id,
            newPatient: patient?.id 
          });
          set({ currentPatient: patient });
        },
        
        triggerEmergency: () => {
          logSecurityEvent('emergency_triggered', { 
            userId: get().currentUser?.id,
            timestamp: new Date().toISOString()
          });
          set({ activeEmergency: true });
        }
      }),
      {
        name: 'medical-app-state',
        partialize: (state) => ({
          // Solo persistir datos no sensibles
          userPreferences: state.userPreferences
        })
      }
    )
  )
);
```

## 🧪 Testing Automatizado con Vitest

### Estrategia de Testing Médico
- **Testing pyramid**: 70% unit, 20% integration, 10% E2E
- **Critical path testing**: Flujos médicos críticos 100% cubiertos
- **Security testing**: Verificar permisos y validaciones
- **Accessibility testing**: Compliance WCAG automático

```typescript
// ✅ Test de componente médico
describe('MedicalRecordForm', () => {
  it('should validate medical data before submission', async () => {
    const mockPatient = createMockPatient();
    const mockOnSubmit = vi.fn();
    
    render(
      <MedicalRecordForm 
        patient={mockPatient} 
        onSubmit={mockOnSubmit} 
      />
    );
    
    // Probar validación de diagnóstico
    const diagnosisInput = screen.getByLabelText(/diagnóstico/i);
    await user.type(diagnosisInput, 'Dx'); // Muy corto
    
    const submitButton = screen.getByRole('button', { name: /guardar/i });
    await user.click(submitButton);
    
    // Verificar que no se envía con datos inválidos
    expect(mockOnSubmit).not.toHaveBeenCalled();
    expect(screen.getByText(/diagnóstico debe tener al menos/i)).toBeInTheDocument();
  });

  it('should log security events on form submission', async () => {
    const mockLogSecurityEvent = vi.spyOn(logger, 'logSecurityEvent');
    
    // ... setup y acciones del test
    
    expect(mockLogSecurityEvent).toHaveBeenCalledWith(
      'medical_record_created',
      expect.objectContaining({
        patientId: mockPatient.id,
        createdBy: mockUser.id
      })
    );
  });
});

// ✅ Test de hook médico
describe('useMedicalHistory', () => {
  it('should handle unauthorized access gracefully', async () => {
    const mockUnauthorizedUser = createMockUser({ role: 'patient' });
    
    const { result } = renderHook(() => 
      useMedicalHistory('other-patient-id'), {
        wrapper: ({ children }) => (
          <AuthProvider user={mockUnauthorizedUser}>
            {children}
          </AuthProvider>
        )
      }
    );
    
    await waitFor(() => {
      expect(result.current.error).toBeTruthy();
      expect(result.current.error?.message).toContain('Unauthorized');
    });
  });
});
```

### Configuración de Testing
```javascript
// vitest.config.ts
export default defineConfig({
  test: {
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    coverage: {
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'src/test/',
        '**/*.d.ts',
        '**/*.config.*'
      ],
      thresholds: {
        global: {
          statements: 80,
          branches: 75,
          functions: 80,
          lines: 80
        },
        // Cobertura más alta para módulos críticos
        'src/features/auth/**': {
          statements: 95,
          branches: 90
        },
        'src/features/emergency/**': {
          statements: 95,
          branches: 95
        }
      }
    }
  }
});
```

## ⚠️ Manejo de Errores Médicos

### Error Boundaries Especializados
- **Medical Error Boundary**: Capturar errores en interfaces médicas
- **Fallback UI informativo**: Mostrar información útil sin exponer datos
- **Error reporting**: Integración con servicio de monitoreo médico
- **Recovery mechanisms**: Recuperación automática cuando sea posible

```typescript
// ✅ Error Boundary médico
class MedicalErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, errorInfo: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, errorInfo: error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Log crítico para errores médicos
    logSecurityEvent('critical_medical_error', {
      error: error.message,
      componentStack: errorInfo.componentStack,
      userId: this.props.user?.id,
      patientId: this.props.currentPatient?.id,
      timestamp: new Date().toISOString(),
      severity: 'critical'
    });

    // Reportar a servicio de monitoreo
    if (process.env.NODE_ENV === 'production') {
      reportMedicalError(error, {
        user: this.props.user,
        context: 'medical_interface',
        additionalInfo: errorInfo
      });
    }
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="medical-error-fallback">
          <h2>Error en la aplicación médica</h2>
          <p>Se ha producido un error inesperado. El personal técnico ha sido notificado.</p>
          <Button 
            onClick={() => window.location.reload()}
            variant="outline"
          >
            Recargar aplicación
          </Button>
          {process.env.NODE_ENV === 'development' && (
            <details className="mt-4">
              <summary>Detalles del error (solo en desarrollo)</summary>
              <pre>{this.state.errorInfo?.message}</pre>
            </details>
          )}
        </div>
      );
    }

    return this.props.children;
  }
}
```

### Logging Estructurado para Auditoría
```typescript
// ✅ Logger médico con niveles de auditoría
interface MedicalLogEvent {
  eventType: 'access' | 'modification' | 'security' | 'emergency' | 'compliance';
  severity: 'info' | 'warning' | 'error' | 'critical';
  userId?: string;
  patientId?: string;
  resourceId?: string;
  action: string;
  metadata?: Record<string, any>;
  timestamp: string;
  ipAddress?: string;
  userAgent?: string;
}

class MedicalLogger {
  logMedicalEvent(event: MedicalLogEvent) {
    const enhancedEvent = {
      ...event,
      timestamp: new Date().toISOString(),
      sessionId: getCurrentSessionId(),
      environment: process.env.NODE_ENV
    };

    // Log local para desarrollo
    console.log(`[MEDICAL] ${event.severity.toUpperCase()}: ${event.action}`, enhancedEvent);

    // En producción, enviar a servicio de auditoría
    if (process.env.NODE_ENV === 'production') {
      sendToAuditService(enhancedEvent);
    }

    // Para eventos críticos, notificar inmediatamente
    if (event.severity === 'critical') {
      notifySecurityTeam(enhancedEvent);
    }
  }
}

export const medicalLogger = new MedicalLogger();
```

## 📈 Performance y Escalabilidad Médica

### Next.js 15 Optimizations
- **Server Components**: Usar para datos médicos no interactivos
- **Client Components**: Solo cuando necesite interactividad
- **Code splitting**: Lazy loading para dashboards especializados
- **Image optimization**: Optimizar imágenes médicas (rayos X, etc.)

```typescript
// ✅ Code splitting por rol médico
const DoctorDashboard = dynamic(() => import('@/features/doctor/DoctorDashboard'), {
  loading: () => <DashboardSkeleton role="doctor" />,
  ssr: false // Evitar hidration mismatch con datos sensibles
});

const PatientPortal = dynamic(() => import('@/features/patient/PatientPortal'), {
  loading: () => <PortalSkeleton role="patient" />
});

// ✅ Server component para datos médicos estáticos
async function MedicalRecordSummary({ patientId }: { patientId: string }) {
  const record = await getMedicalRecord(patientId); // Server-side fetch
  
  return (
    <div className="medical-summary">
      <h3>Resumen Médico</h3>
      {/* Render estático de datos médicos */}
    </div>
  );
}
```

### Database Performance
- **Indexes médicos**: Optimizar consultas frecuentes
- **RLS optimization**: Políticas eficientes sin N+1 queries
- **Connection pooling**: Gestión eficiente de conexiones
- **Query optimization**: Seleccionar solo campos necesarios

```sql
-- ✅ Indexes específicos para consultas médicas
CREATE INDEX idx_medical_records_patient_date 
ON medical_records (patient_id, created_at DESC);

CREATE INDEX idx_appointments_doctor_date 
ON appointments (doctor_id, appointment_date) 
WHERE status = 'scheduled';

CREATE INDEX idx_emergency_contacts_patient 
ON emergency_contacts (patient_id) 
WHERE is_active = true;

-- ✅ Función RLS optimizada
CREATE OR REPLACE FUNCTION check_medical_access(
  user_id uuid,
  patient_id uuid,
  access_type text
)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, extensions
AS $$
BEGIN
  -- Caché de verificaciones frecuentes
  RETURN EXISTS (
    SELECT 1 FROM user_permissions_cache 
    WHERE user_id = $1 
    AND patient_id = $2 
    AND access_type = $3
    AND expires_at > NOW()
  );
END;
$$;
```

## 🚀 Deployment y CI/CD Médico

### Vercel Configuration
```javascript
// vercel.json
{
  "functions": {
    "app/api/**": {
      "maxDuration": 30
    }
  },
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        {
          "key": "X-Content-Type-Options",
          "value": "nosniff"
        },
        {
          "key": "X-Frame-Options",
          "value": "DENY"
        },
        {
          "key": "Strict-Transport-Security",
          "value": "max-age=31536000; includeSubDomains"
        }
      ]
    }
  ]
}
```

### Environment Configuration
```bash
# .env.local.example
# SUPABASE CONFIGURATION (REQUIRED)
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_anon_key_here
SUPABASE_SERVICE_ROLE_KEY=your_service_role_key_here

# MEDICAL COMPLIANCE
MEDICAL_AUDIT_ENDPOINT=https://audit.yourcompany.com
HIPAA_COMPLIANCE_MODE=true
ENCRYPTION_KEY=your_encryption_key_here

# ENVIRONMENT
NODE_ENV=production
NEXT_PUBLIC_SITE_URL=https://yourmedicalplatform.com

# SECURITY
RATE_LIMIT_ENABLED=true
SESSION_TIMEOUT_MINUTES=30
MAX_LOGIN_ATTEMPTS=3
```

## 📚 Documentación Médica

### Requisitos de Documentación
- **Medical API Documentation**: Documentar endpoints médicos con OpenAPI
- **Compliance Documentation**: Documentar medidas de compliance
- **Security Procedures**: Procedimientos de seguridad documentados
- **Emergency Protocols**: Protocolos de emergencia claros

### Comentarios JSDoc Médicos
```typescript
/**
 * Creates a new medical record with full audit trail
 * 
 * @param patientId - UUID of the patient (validated against permissions)
 * @param doctorId - UUID of the creating doctor
 * @param recordData - Medical record data (validated with Zod schema)
 * @returns Promise resolving to created medical record
 * 
 * @throws {UnauthorizedError} When doctor lacks permission to create records for patient
 * @throws {ValidationError} When medical data fails validation
 * @throws {ComplianceError} When action violates medical compliance rules
 * 
 * @compliance This function logs all creation attempts for HIPAA audit trail
 * @security Validates permissions before any database operation
 * 
 * @example
 * ```typescript
 * const record = await createMedicalRecord(
 *   'patient-uuid',
 *   'doctor-uuid',
 *   {
 *     diagnosis: 'Hypertension',
 *     treatment: 'ACE inhibitors',
 *     medications: [...],
 *     confidentialityLevel: 'restricted'
 *   }
 * );
 * ```
 */
async function createMedicalRecord(
  patientId: string,
  doctorId: string,
  recordData: MedicalRecordInput
): Promise<MedicalRecord> {
  // Implementation
}
```

## 🔄 Git Workflow Médico

### Conventional Commits para Aplicaciones Médicas
```bash
# Features médicas
feat(auth): add emergency access override
feat(records): implement medical history encryption
feat(chat): add urgent message prioritization

# Bug fixes críticos
fix(security): patch RLS vulnerability in patient data
fix(emergency): resolve contact notification failure
fix(compliance): fix audit trail logging

# Compliance y seguridad
compliance(hipaa): add patient data encryption
security(rls): strengthen medical record policies
audit(logging): enhance security event tracking

# Performance médico
perf(db): optimize medical record queries
perf(ui): lazy load patient dashboard components
```

### Branch Protection Rules Elite
- **main/production**: Requiere review médico + técnico + security approval
- **staging**: Testing completo de compliance + performance validation
- **feature branches**: Nombrar con dominio médico (`feature/medical-records-encryption`)
- **hotfix branches**: `hotfix/critical-security-patch` para emergencias
- **Automatic dependency updates**: Dependabot con security focus

### Git Hooks Automatizados
```bash
# ✅ Pre-commit hook para calidad médica
#!/bin/sh
# .git/hooks/pre-commit

echo "🏥 Verificando calidad médica antes del commit..."

# 1. Verificar límite de líneas
echo "📏 Verificando límite de líneas por archivo..."
files_over_limit=$(find src -name "*.ts" -o -name "*.tsx" | xargs wc -l | awk '$1 > 300 {print $2}')
if [ ! -z "$files_over_limit" ]; then
  echo "❌ Los siguientes archivos exceden 300 líneas:"
  echo "$files_over_limit"
  exit 1
fi

# 2. Verificar datos médicos hardcodeados
echo "🔒 Verificando datos médicos sensibles..."
if git diff --cached --name-only | xargs grep -l "V-[0-9]\{7,8\}\|E-[0-9]\{7,8\}" > /dev/null 2>&1; then
  echo "❌ Se detectaron posibles cédulas hardcodeadas"
  exit 1
fi

# 3. Verificar imports relativos largos
echo "📦 Verificando estructura de imports..."
long_imports=$(git diff --cached --name-only | xargs grep -l "\.\./\.\./\.\." 2>/dev/null || true)
if [ ! -z "$long_imports" ]; then
  echo "⚠️ Imports relativos muy largos detectados. Considerar usar alias de path."
fi

# 4. Ejecutar tests de archivos modificados
echo "🧪 Ejecutando tests relacionados..."
npm run test:changed

echo "✅ Verificaciones de calidad médica completadas"
```

## 📊 Monitoreo y Observabilidad Médica

### Métricas de Sistema Críticas
- **SLA médicos**: 99.9% uptime para sistemas críticos
- **Latencia objetivo**: < 200ms para operaciones médicas críticas
- **Error rate**: < 0.1% para operaciones médicas
- **Alert thresholds**: Configurados para emergencias médicas

```typescript
// ✅ Sistema de monitoreo médico avanzado
interface MedicalSystemMetrics {
  realTime: {
    activeUsers: number;
    concurrentMedicalSessions: number;
    emergencyAlertsActive: number;
    systemResponseTime: number;
  };
  medical: {
    appointmentsToday: number;
    criticalPatients: number;
    medicationAlertsActive: number;
    complianceViolations: number;
  };
  technical: {
    errorRate: number;
    memoryUsage: number;
    databaseConnections: number;
    queueSize: number;
  };
}

// ✅ Alertas médicas automatizadas
class MedicalAlertSystem {
  async checkCriticalMetrics(): Promise<void> {
    const metrics = await this.getSystemMetrics();
    
    // Alerta crítica: Error rate alto
    if (metrics.technical.errorRate > 0.5) {
      await this.triggerCriticalAlert({
        level: 'CRITICAL',
        message: 'High error rate detected in medical system',
        affectedServices: ['appointments', 'medical-records'],
        escalationPath: ['tech-lead', 'medical-director', 'cto']
      });
    }
    
    // Alerta médica: Pacientes críticos sin atención
    if (metrics.medical.criticalPatients > 5) {
      await this.triggerMedicalAlert({
        level: 'URGENT',
        message: 'Multiple critical patients require immediate attention',
        notifyRoles: ['emergency-doctor', 'head-nurse', 'medical-director']
      });
    }
  }
}

// ✅ Logging estructurado para análisis
const medicalLogger = createLogger({
  level: 'info',
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.errors({ stack: true }),
    winston.format.json()
  ),
  defaultMeta: { 
    service: 'platform-medicos',
    environment: process.env.NODE_ENV,
    version: process.env.APP_VERSION
  },
  transports: [
    new winston.transports.File({ 
      filename: 'logs/medical-error.log', 
      level: 'error',
      maxsize: 5242880, // 5MB
      maxFiles: 10
    }),
    new winston.transports.File({ 
      filename: 'logs/medical-audit.log',
      level: 'info',
      maxsize: 10485760, // 10MB
      maxFiles: 30
    })
  ]
});
```

### Dashboards de Observabilidad
```typescript
// ✅ Dashboard médico en tiempo real
const MedicalDashboard = () => {
  const { data: metrics, isLoading } = useRealTimeMetrics();
  const { data: alerts } = useActiveAlerts();
  
  return (
    <div className="medical-dashboard">
      <MetricCard
        title="Pacientes Activos"
        value={metrics?.activePatients}
        trend={metrics?.patientTrend}
        threshold={{ warning: 100, critical: 150 }}
      />
      
      <MetricCard
        title="Tiempo Respuesta Sistema"
        value={`${metrics?.responseTime}ms`}
        trend={metrics?.responseTrend}
        threshold={{ warning: 500, critical: 1000 }}
      />
      
      <AlertPanel
        alerts={alerts}
        onAcknowledge={handleAlertAcknowledge}
        onEscalate={handleAlertEscalate}
      />
      
      <SystemHealthIndicator
        services={metrics?.serviceHealth}
        overallHealth={metrics?.overallHealthScore}
      />
    </div>
  );
};
```

## 📚 Documentación Elite y Estándares

### Documentación Living (Auto-generada)
- **API Documentation**: OpenAPI 3.0 con ejemplos médicos reales
- **Component Documentation**: Storybook con casos de uso médicos
- **Architecture Decision Records**: Para decisiones críticas médicas
- **Security Documentation**: Procedimientos de seguridad actualizados
- **Compliance Documentation**: Auditorías y certificaciones

```typescript
// ✅ Documentación automática de APIs médicas
/**
 * @openapi
 * /api/medical-records:
 *   post:
 *     summary: Create medical record
 *     description: Creates a new medical record with full audit trail and permission validation
 *     tags: [Medical Records]
 *     security:
 *       - BearerAuth: []
 *     requestBody:
 *       required: true
 *       content:
 *         application/json:
 *           schema:
 *             $ref: '#/components/schemas/MedicalRecordInput'
 *           examples:
 *             routine_checkup:
 *               summary: Routine medical checkup
 *               value:
 *                 patientId: "550e8400-e29b-41d4-a716-446655440000"
 *                 diagnosis: "Routine annual physical examination"
 *                 treatment: "Continue current medication regimen"
 *                 confidentialityLevel: "restricted"
 *             emergency_record:
 *               summary: Emergency medical record
 *               value:
 *                 patientId: "550e8400-e29b-41d4-a716-446655440001"
 *                 diagnosis: "Acute myocardial infarction"
 *                 treatment: "Emergency cardiac intervention required"
 *                 confidentialityLevel: "confidential"
 *                 emergencyAccess: true
 *     responses:
 *       201:
 *         description: Medical record created successfully
 *         content:
 *           application/json:
 *             schema:
 *               $ref: '#/components/schemas/MedicalRecord'
 *       401:
 *         $ref: '#/components/responses/Unauthorized'
 *       403:
 *         $ref: '#/components/responses/InsufficientPermissions'
 *       422:
 *         $ref: '#/components/responses/ValidationError'
 */
```

## ✅ Checklist de Compliance Médico Elite

### Antes de cada PR (Pull Request):
- [ ] **Arquitectura y Responsabilidad**
  - [ ] Archivo no supera 300 líneas (ESTRICTO)
  - [ ] Una sola responsabilidad por archivo verificada
  - [ ] Principios SOLID aplicados correctamente
  - [ ] Dependency Injection implementada donde corresponde
  - [ ] Separación de capas (Domain, Application, Infrastructure) respetada
  
- [ ] **TypeScript Elite**
  - [ ] Tipos explícitos para todos los datos médicos
  - [ ] Branded types usados para IDs médicos
  - [ ] Union types discriminados para estados complejos
  - [ ] Template literal types para formatos específicos
  - [ ] Utility types para transformaciones seguras
  
- [ ] **Seguridad Médica**
  - [ ] No hay datos médicos hardcodeados (cédulas, historiales, etc.)
  - [ ] RLS policies verificadas para nuevas tablas
  - [ ] Permisos granulares validados por rol médico
  - [ ] Audit trail implementado para cambios críticos
  - [ ] Encriptación aplicada a datos sensibles
  - [ ] Rate limiting configurado para endpoints críticos
  
- [ ] **Validaciones Zod Avanzadas**
  - [ ] Schemas con validaciones médicas específicas
  - [ ] Transformaciones automáticas implementadas
  - [ ] Validaciones condicionales por rol médico
  - [ ] Error messages informativos en español
  
- [ ] **Testing de Clase Mundial**
  - [ ] Tests unitarios para funciones médicas críticas
  - [ ] Property-based testing para validaciones complejas
  - [ ] Tests de seguridad para nuevos permisos
  - [ ] Tests de accessibility WCAG 2.1 AA
  - [ ] Tests de performance para componentes críticos
  - [ ] Cobertura mínima 80% (95% para módulos críticos)
  
- [ ] **Performance y Escalabilidad**
  - [ ] Lazy loading implementado correctamente
  - [ ] Memoización selectiva aplicada
  - [ ] Queries optimizadas sin N+1 problems
  - [ ] Code splitting por roles médicos
  - [ ] Bundle size impacto minimizado (< 5KB por componente)
  
- [ ] **Compliance HIPAA**
  - [ ] Documentación médica actualizada
  - [ ] Variables de entorno configuradas securely
  - [ ] Migraciones de BD aplicadas y verificadas
  - [ ] Logging de seguridad implementado
  - [ ] Métricas de monitoreo configuradas
  - [ ] Alertas médicas automatizadas activadas

### Antes de deployment a producción:
- [ ] **Medical Compliance Verification**
  - [ ] HIPAA compliance checklist completado
  - [ ] Audit trail funcionando correctamente
  - [ ] Backup y recovery procedures verificados
  - [ ] Security monitoring configurado
- [ ] **Performance Validation**
  - [ ] Load testing en endpoints médicos críticos
  - [ ] Database performance verified
  - [ ] CDN configurado para assets médicos
- [ ] **Security Final Check**
  - [ ] Penetration testing completado
  - [ ] SSL/TLS certificados válidos
  - [ ] Environment variables seguras
  - [ ] Rate limiting configurado

---

## 🚨 RECORDATORIOS CRÍTICOS ELITE

> **⚠️ DATOS MÉDICOS SENSIBLES**: Esta aplicación maneja información médica protegida clase mundial. Cada línea de código debe considerar la privacidad y seguridad del paciente con máxima rigurosidad.

> **🔒 COMPLIANCE OBLIGATORIO**: El incumplimiento de estas reglas puede resultar en violaciones de compliance médico, riesgos legales y pérdida de certificaciones. Son NO NEGOCIABLES.

> **📊 AUDIT TRAIL TOTAL**: Todas las operaciones críticas deben ser registradas para auditoría médica. Sistema de trazabilidad completo obligatorio.

> **🚀 PERFORMANCE CRÍTICO**: En emergencias médicas, cada segundo cuenta. El código debe ser eficiente, robusto y escalable para manejar picos de demanda.

> **🏗️ ARQUITECTURA LIMPIA**: La responsabilidad única y la separación de capas son fundamentales para el mantenimiento a largo plazo de una plataforma médica crítica.

> **🧪 TESTING OBLIGATORIO**: Sin tests comprehensivos, NO HAY DEPLOYMENT. La vida de los pacientes puede depender de la confiabilidad del código.

> **📈 MONITOREO CONTINUO**: Sistema de observabilidad 24/7 para detectar problemas antes de que afecten a pacientes o personal médico.

---

## 🏆 Métricas de Excelencia (KPIs de Calidad)

### Objetivos Técnicos Elite
- **Code Quality Score**: > 95/100
- **Test Coverage**: > 90% (99% en módulos críticos)
- **Performance**: < 200ms respuesta promedio
- **Security Score**: 100/100 (sin vulnerabilidades)
- **Uptime**: 99.99% para servicios críticos
- **Documentation Coverage**: 100% APIs públicas

### Métricas de Refactorización Continua
- **Files > 300 lines**: 0 (tolerancia absoluta cero)
- **Cyclomatic Complexity**: < 10 por función
- **Duplicate Code**: < 1%
- **Technical Debt**: < 5% del tiempo total
- **Dependency Freshness**: < 30 días desactualización

---

## 🎖️ Certificación de Desarrollador Médico

Para trabajar en Platform Médicos, cada desarrollador debe:

1. **✅ Dominar estas reglas completamente**
2. **✅ Pasar auditoría de código médico**
3. **✅ Completar training en compliance HIPAA**
4. **✅ Demostrar expertise en arquitectura limpia**
5. **✅ Aprobar simulacro de emergencia médica técnica**

---

**🏥 THESE RULES SAVE LIVES. NO EXCEPTIONS. NO SHORTCUTS. MEDICAL EXCELLENCE THROUGH CODE EXCELLENCE.**

**Estas reglas son obligatorias para mantener la integridad, seguridad y compliance de la plataforma médica de clase mundial. Cada desarrollador debe familiarizarse y aplicar estas prácticas consistentemente. La excelencia médica se logra a través de la excelencia en el código.**