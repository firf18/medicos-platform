---
description: "Comprehensive development rules for Platform M√©dicos - A large-scale medical platform with strict compliance requirements"
globs: ["**/*.ts", "**/*.tsx", "**/*.js", "**/*.jsx", "**/*.sql", "**/*.md"]
alwaysApply: true
---

# üìã Reglas y Buenas Pr√°cticas - Platform M√©dicos

> **CR√çTICO**: Esta es una plataforma m√©dica que maneja datos sensibles de salud. Todas las reglas deben seguirse estrictamente para garantizar compliance, seguridad y escalabilidad.

## üéØ Principios Fundamentales

### 1. üîí Seguridad y Compliance M√©dico (CR√çTICO)
- **HIPAA-Style Compliance**: Todos los datos m√©dicos deben estar protegidos y auditados
- **Zero Trust**: Verificar permisos en cada operaci√≥n, nunca confiar en datos del cliente
- **Data Minimization**: Solicitar y procesar solo datos estrictamente necesarios
- **Audit Trail**: Registrar todas las operaciones cr√≠ticas para auditor√≠a
- **Encryption**: Datos sensibles encriptados en tr√°nsito y en reposo

```typescript
// ‚úÖ Correcto - Verificaci√≥n de permisos granular
const canAccessMedicalRecord = await checkPermissions(userId, recordId, 'read');
if (!canAccessMedicalRecord) {
  logSecurityEvent('unauthorized_access_attempt', { userId, recordId });
  throw new UnauthorizedError('Acceso denegado');
}
```

### 2. üèóÔ∏è Arquitectura Escalable por Features
- **Domain-Driven Design**: Organizar c√≥digo por dominio m√©dico (auth, appointments, records, chat)
- **Bounded Contexts**: Cada feature es independiente y cohesiva
- **Clean Architecture**: Separaci√≥n clara entre UI, business logic y data access
- **Vertical Slicing**: Features completas (UI + API + DB) en m√≥dulos independientes

### 3. üìè Responsabilidad √önica Estricta
- **M√°ximo 300 l√≠neas por archivo** (reducido para mejor mantenimiento)
- **Un prop√≥sito por archivo**: Cada archivo debe tener una responsabilidad clara
- **Separation of Concerns**: UI, l√≥gica de negocio y datos completamente separados
- **Single Source of Truth**: Cada pieza de informaci√≥n tiene una fuente autoritativa

## üèóÔ∏è Estructura de Archivos (Arquitectura Multi-Rol)

### Organizaci√≥n por Dominios M√©dicos
```
src/
‚îú‚îÄ‚îÄ app/                    # Next.js 15 App Router
‚îÇ   ‚îú‚îÄ‚îÄ (auth)/            # Autenticaci√≥n y verificaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ (protected)/       # Rutas protegidas con m√∫ltiples roles
‚îÇ   ‚îú‚îÄ‚îÄ doctor/            # Dashboard y funciones para m√©dicos
‚îÇ   ‚îú‚îÄ‚îÄ patient/           # Portal y dashboard para pacientes
‚îÇ   ‚îú‚îÄ‚îÄ clinic/            # Gesti√≥n para cl√≠nicas
‚îÇ   ‚îú‚îÄ‚îÄ laboratory/        # Gesti√≥n para laboratorios
‚îÇ   ‚îú‚îÄ‚îÄ admin/             # Administraci√≥n del sistema
‚îÇ   ‚îú‚îÄ‚îÄ chat/              # Sistema de comunicaci√≥n en tiempo real
‚îÇ   ‚îú‚îÄ‚îÄ search/            # B√∫squeda avanzada global
‚îÇ   ‚îî‚îÄ‚îÄ api/               # API endpoints
‚îú‚îÄ‚îÄ components/            # Componentes por dominio m√©dico
‚îÇ   ‚îú‚îÄ‚îÄ auth/             # Autenticaci√≥n y verificaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ dashboard/        # Dashboards especializados
‚îÇ   ‚îú‚îÄ‚îÄ patient-dashboard/# Dashboard espec√≠fico de pacientes
‚îÇ   ‚îú‚îÄ‚îÄ clinic-dashboard/ # Dashboard espec√≠fico de cl√≠nicas
‚îÇ   ‚îú‚îÄ‚îÄ laboratory-dashboard/ # Dashboard espec√≠fico de laboratorios
‚îÇ   ‚îú‚îÄ‚îÄ chat/             # Componentes de chat m√©dico
‚îÇ   ‚îú‚îÄ‚îÄ search/           # B√∫squeda avanzada
‚îÇ   ‚îú‚îÄ‚îÄ ui/               # Componentes reutilizables del design system
‚îÇ   ‚îî‚îÄ‚îÄ navigation/       # Navegaci√≥n multi-rol
‚îú‚îÄ‚îÄ features/             # Features por dominio m√©dico
‚îÇ   ‚îú‚îÄ‚îÄ auth/            # Sistema de autenticaci√≥n completo
‚îÇ   ‚îú‚îÄ‚îÄ appointments/    # Gesti√≥n de citas m√©dicas
‚îÇ   ‚îú‚îÄ‚îÄ medical-records/ # Historiales m√©dicos
‚îÇ   ‚îú‚îÄ‚îÄ emergency/       # Sistemas de emergencia
‚îÇ   ‚îú‚îÄ‚îÄ notifications/   # Notificaciones m√©dicas cr√≠ticas
‚îÇ   ‚îî‚îÄ‚îÄ compliance/      # Herramientas de compliance
‚îú‚îÄ‚îÄ lib/                 # Configuraciones y utilidades
‚îÇ   ‚îú‚îÄ‚îÄ supabase/       # Cliente Supabase con RLS
‚îÇ   ‚îú‚îÄ‚îÄ validations.ts  # Validaciones m√©dicas espec√≠ficas
‚îÇ   ‚îú‚îÄ‚îÄ logger.ts       # Logging estructurado para auditor√≠a
‚îÇ   ‚îî‚îÄ‚îÄ constants.ts    # Constantes del dominio m√©dico
‚îú‚îÄ‚îÄ hooks/              # Hooks personalizados del dominio
‚îú‚îÄ‚îÄ types/              # Tipos TypeScript por dominio
‚îÇ   ‚îú‚îÄ‚îÄ auth/          # Tipos de autenticaci√≥n
‚îÇ   ‚îú‚îÄ‚îÄ dashboard/     # Tipos de dashboards
‚îÇ   ‚îú‚îÄ‚îÄ database/      # Tipos de base de datos m√©dica
‚îÇ   ‚îî‚îÄ‚îÄ shared/        # Tipos compartidos
‚îú‚îÄ‚îÄ providers/         # Providers de contexto especializados
‚îú‚îÄ‚îÄ test/             # Suite de testing automatizado
‚îî‚îÄ‚îÄ middleware.ts     # Middleware de protecci√≥n de rutas
```

### Convenciones de Nomenclatura M√©dica
- **Componentes**: PascalCase con sufijo de dominio (`MedicalRecordForm.tsx`, `EmergencyContactsList.tsx`)
- **Hooks**: camelCase m√©dico espec√≠fico (`useMedicalHistory.ts`, `useEmergencyContacts.ts`)
- **Utilidades**: camelCase descriptivo (`validateMedicalID.ts`, `formatDiagnosis.ts`)
- **Constantes m√©dicas**: UPPER_SNAKE_CASE (`MEDICAL_SPECIALTIES.ts`, `EMERGENCY_PROTOCOLS.ts`)
- **Rutas**: kebab-case (`patient-dashboard/`, `emergency-contacts/`)

## üìù Reglas de C√≥digo TypeScript Estricto

### TypeScript para Datos M√©dicos
- **Tipos expl√≠citos obligatorios**: Todos los datos m√©dicos deben estar tipados
- **Strict mode activado**: `"strict": true` en tsconfig.json
- **No usar `any`**: Usar tipos espec√≠ficos o `unknown` para datos m√©dicos
- **Union types para estados m√©dicos**: Usar enums para estados cr√≠ticos
- **Zod para validaci√≥n runtime**: Validar datos m√©dicos en runtime

```typescript
// ‚úÖ Correcto - Tipos m√©dicos expl√≠citos
interface MedicalRecord {
  id: string;
  patientId: string;
  doctorId: string;
  diagnosis: string;
  treatment: string;
  medications: Medication[];
  allergies: Allergy[];
  vitalSigns: VitalSigns;
  emergencyContacts: EmergencyContact[];
  confidentialityLevel: 'public' | 'restricted' | 'confidential' | 'secret';
  lastModified: Date;
  lastModifiedBy: string;
}

// ‚úÖ Validaci√≥n con Zod para datos cr√≠ticos
const MedicalRecordSchema = z.object({
  diagnosis: z.string().min(10).max(500),
  medications: z.array(MedicationSchema),
  allergies: z.array(AllergySchema),
  confidentialityLevel: z.enum(['public', 'restricted', 'confidential', 'secret'])
});

// ‚ùå Incorrecto - Datos m√©dicos sin tipar
const record: any = getMedicalRecord(); // NUNCA
```

### Componentes React para Interfaces M√©dicas
- **Functional components √∫nicamente**: No class components
- **Props inmutables**: Nunca mutar props m√©dicas
- **Memoizaci√≥n selectiva**: Solo componentes de alta carga (listas de pacientes, historiales)
- **Error boundaries obligatorios**: Capturar errores en interfaces cr√≠ticas
- **Accessibility compliance**: WCAG 2.1 AA para interfaces m√©dicas

```typescript
// ‚úÖ Estructura correcta de componente m√©dico
import { memo, useCallback, useEffect } from 'react';
import { logSecurityEvent } from '@/lib/logger';

interface MedicalRecordViewProps {
  record: MedicalRecord;
  canEdit: boolean;
  onUpdate: (record: Partial<MedicalRecord>) => Promise<void>;
  onSecurityEvent: (event: SecurityEvent) => void;
}

const MedicalRecordView = memo<MedicalRecordViewProps>(({ 
  record, 
  canEdit, 
  onUpdate, 
  onSecurityEvent 
}) => {
  // Audit trail - registrar visualizaci√≥n
  useEffect(() => {
    logSecurityEvent('medical_record_viewed', {
      recordId: record.id,
      patientId: record.patientId,
      timestamp: new Date().toISOString()
    });
  }, [record.id, record.patientId]);

  const handleUpdate = useCallback(async (updates: Partial<MedicalRecord>) => {
    try {
      await onUpdate(updates);
      logSecurityEvent('medical_record_updated', {
        recordId: record.id,
        updatedFields: Object.keys(updates)
      });
    } catch (error) {
      onSecurityEvent({ type: 'update_failed', error, recordId: record.id });
    }
  }, [record.id, onUpdate, onSecurityEvent]);

  return (
    <div className="medical-record-view" role="region" aria-label="Registro m√©dico">
      {/* Contenido del componente */}
    </div>
  );
});

MedicalRecordView.displayName = 'MedicalRecordView';
export default MedicalRecordView;
```

## üîê Autenticaci√≥n y Seguridad Multi-Rol

### Supabase Auth con RLS Granular
- **Row Level Security obligatorio**: Todas las tablas m√©dicas con RLS
- **Pol√≠ticas granulares**: Verificar permisos espec√≠ficos por rol y contexto
- **Functions con SECURITY DEFINER**: Funciones de BD con search_path fijo
- **Rate limiting**: Protecci√≥n contra ataques de fuerza bruta
- **Session recovery**: Manejo robusto de sesiones expiradas

```typescript
// ‚úÖ Verificaci√≥n de permisos granular
const hasAccess = await supabase.rpc('check_medical_record_access', {
  p_user_id: user.id,
  p_record_id: recordId,
  p_action: 'read',
  p_context: 'emergency' // contexto adicional para emergencias
});

// ‚úÖ Pol√≠ticas RLS espec√≠ficas por rol
-- En migration SQL
CREATE POLICY "doctors_read_patients" ON medical_records
  FOR SELECT USING (
    auth.role() = 'doctor' AND 
    doctor_id = auth.uid() OR
    EXISTS (
      SELECT 1 FROM appointments 
      WHERE patient_id = medical_records.patient_id 
      AND doctor_id = auth.uid()
      AND status = 'active'
    )
  );
```

### Protecci√≥n de Rutas Multi-Nivel
- **Middleware de Next.js**: Primera l√≠nea de defensa
- **AuthGuard components**: Verificaci√≥n granular en componentes
- **Role-based access**: Verificar roles espec√≠ficos por contexto
- **Emergency access**: Protocolos especiales para emergencias m√©dicas

```typescript
// ‚úÖ Middleware con protecci√≥n multi-rol
export async function middleware(request: NextRequest) {
  const { session, role } = await verifySession(request);
  
  if (!session) {
    return redirectToLogin(request);
  }

  // Verificaci√≥n espec√≠fica por ruta m√©dica
  if (request.nextUrl.pathname.startsWith('/doctor/')) {
    if (role !== 'doctor') {
      logSecurityEvent('unauthorized_doctor_access', { 
        userId: session.user.id, 
        attemptedPath: request.nextUrl.pathname 
      });
      return NextResponse.redirect(new URL('/auth/unauthorized', request.url));
    }
  }

  // Protecci√≥n especial para datos cr√≠ticos
  if (request.nextUrl.pathname.includes('/emergency/')) {
    const hasEmergencyAccess = await verifyEmergencyAccess(session.user.id);
    if (!hasEmergencyAccess) {
      return NextResponse.redirect(new URL('/auth/insufficient-privileges', request.url));
    }
  }

  return NextResponse.next();
}
```

## üé® UI/UX para Interfaces M√©dicas

### Tailwind CSS con Design System M√©dico
- **Accessibility-first**: WCAG 2.1 AA compliance obligatorio
- **Color coding m√©dico**: Colores espec√≠ficos para urgencias, warnings, success
- **High contrast**: Garantizar legibilidad en entornos m√©dicos
- **Mobile-first responsive**: Dise√±o para dispositivos m√©dicos diversos

### Componentes UI Especializados
- **Radix UI**: Base accesible para componentes complejos
- **Shadcn/ui**: Design system consistente adaptado al dominio m√©dico
- **Loading states**: Estados de carga para operaciones cr√≠ticas
- **Error states**: Manejo de errores user-friendly pero informativo

```typescript
// ‚úÖ Componente con variants m√©dicos
const alertVariants = cva(
  "border px-4 py-3 rounded-md",
  {
    variants: {
      variant: {
        emergency: "bg-red-50 border-red-200 text-red-800",
        warning: "bg-yellow-50 border-yellow-200 text-yellow-800",
        success: "bg-green-50 border-green-200 text-green-800",
        info: "bg-blue-50 border-blue-200 text-blue-800",
        critical: "bg-red-100 border-red-300 text-red-900 animate-pulse"
      },
      urgency: {
        low: "",
        medium: "border-2",
        high: "border-4 shadow-lg",
        critical: "border-4 shadow-xl animate-bounce"
      }
    }
  }
);
```

## üìä Manejo de Datos M√©dicos

### React Query para Estado del Servidor M√©dico
- **Invalidaci√≥n inteligente**: Cache invalidation para datos cr√≠ticos
- **Background updates**: Actualizaciones en tiempo real para datos vitales
- **Error retry logic**: Reintentos espec√≠ficos para operaciones m√©dicas
- **Optimistic updates**: Solo para operaciones no cr√≠ticas

```typescript
// ‚úÖ Query m√©dica con invalidaci√≥n autom√°tica
const { data: medicalRecords, isLoading, error } = useQuery({
  queryKey: ['medicalRecords', patientId, { includeEmergency: true }],
  queryFn: async () => {
    const { data, error } = await supabase
      .from('medical_records')
      .select(`
        *,
        medications (*),
        allergies (*),
        emergency_contacts (*)
      `)
      .eq('patient_id', patientId)
      .order('created_at', { ascending: false });
    
    if (error) {
      logSecurityEvent('medical_record_access_error', { patientId, error });
      throw error;
    }
    
    return data;
  },
  staleTime: 5 * 60 * 1000, // 5 minutos para datos m√©dicos
  refetchInterval: 30 * 1000, // Actualizar cada 30 segundos
  refetchOnWindowFocus: true, // Cr√≠tico para datos m√©dicos actualizados
});

// ‚úÖ Mutation con audit trail
const updateMedicalRecord = useMutation({
  mutationFn: async (updates: Partial<MedicalRecord>) => {
    const { data, error } = await supabase
      .from('medical_records')
      .update({
        ...updates,
        last_modified: new Date().toISOString(),
        last_modified_by: user.id
      })
      .eq('id', recordId)
      .select();
      
    if (error) throw error;
    return data;
  },
  onSuccess: () => {
    // Invalidar queries relacionadas
    queryClient.invalidateQueries(['medicalRecords', patientId]);
    queryClient.invalidateQueries(['patientSummary', patientId]);
    
    logSecurityEvent('medical_record_updated', {
      recordId,
      patientId,
      updatedBy: user.id
    });
  },
  onError: (error) => {
    logSecurityEvent('medical_record_update_failed', {
      recordId,
      patientId,
      error: error.message
    });
  }
});
```

### Zustand para Estado Global M√©dico
- **Estado m√≠nimo**: Solo datos cr√≠ticos compartidos
- **Persistence selectiva**: Solo datos no sensibles en localStorage
- **State splitting**: Separar estado por dominio m√©dico
- **Security boundaries**: No almacenar datos m√©dicos sensibles

```typescript
// ‚úÖ Store m√©dico seguro
interface MedicalAppState {
  currentPatient: { id: string; name: string } | null; // Solo datos b√°sicos
  activeEmergency: boolean;
  notifications: MedicalNotification[];
  userPreferences: UserPreferences;
}

const useMedicalStore = create<MedicalAppState>()(
  devtools(
    persist(
      (set, get) => ({
        currentPatient: null,
        activeEmergency: false,
        notifications: [],
        userPreferences: {},
        
        setCurrentPatient: (patient) => {
          logSecurityEvent('patient_context_changed', { 
            previousPatient: get().currentPatient?.id,
            newPatient: patient?.id 
          });
          set({ currentPatient: patient });
        },
        
        triggerEmergency: () => {
          logSecurityEvent('emergency_triggered', { 
            userId: get().currentUser?.id,
            timestamp: new Date().toISOString()
          });
          set({ activeEmergency: true });
        }
      }),
      {
        name: 'medical-app-state',
        partialize: (state) => ({
          // Solo persistir datos no sensibles
          userPreferences: state.userPreferences
        })
      }
    )
  )
);
```

## üß™ Testing Automatizado con Vitest

### Estrategia de Testing M√©dico
- **Testing pyramid**: 70% unit, 20% integration, 10% E2E
- **Critical path testing**: Flujos m√©dicos cr√≠ticos 100% cubiertos
- **Security testing**: Verificar permisos y validaciones
- **Accessibility testing**: Compliance WCAG autom√°tico

```typescript
// ‚úÖ Test de componente m√©dico
describe('MedicalRecordForm', () => {
  it('should validate medical data before submission', async () => {
    const mockPatient = createMockPatient();
    const mockOnSubmit = vi.fn();
    
    render(
      <MedicalRecordForm 
        patient={mockPatient} 
        onSubmit={mockOnSubmit} 
      />
    );
    
    // Probar validaci√≥n de diagn√≥stico
    const diagnosisInput = screen.getByLabelText(/diagn√≥stico/i);
    await user.type(diagnosisInput, 'Dx'); // Muy corto
    
    const submitButton = screen.getByRole('button', { name: /guardar/i });
    await user.click(submitButton);
    
    // Verificar que no se env√≠a con datos inv√°lidos
    expect(mockOnSubmit).not.toHaveBeenCalled();
    expect(screen.getByText(/diagn√≥stico debe tener al menos/i)).toBeInTheDocument();
  });

  it('should log security events on form submission', async () => {
    const mockLogSecurityEvent = vi.spyOn(logger, 'logSecurityEvent');
    
    // ... setup y acciones del test
    
    expect(mockLogSecurityEvent).toHaveBeenCalledWith(
      'medical_record_created',
      expect.objectContaining({
        patientId: mockPatient.id,
        createdBy: mockUser.id
      })
    );
  });
});

// ‚úÖ Test de hook m√©dico
describe('useMedicalHistory', () => {
  it('should handle unauthorized access gracefully', async () => {
    const mockUnauthorizedUser = createMockUser({ role: 'patient' });
    
    const { result } = renderHook(() => 
      useMedicalHistory('other-patient-id'), {
        wrapper: ({ children }) => (
          <AuthProvider user={mockUnauthorizedUser}>
            {children}
          </AuthProvider>
        )
      }
    );
    
    await waitFor(() => {
      expect(result.current.error).toBeTruthy();
      expect(result.current.error?.message).toContain('Unauthorized');
    });
  });
});
```

### Configuraci√≥n de Testing
```javascript
// vitest.config.ts
export default defineConfig({
  test: {
    environment: 'jsdom',
    setupFiles: ['./src/test/setup.ts'],
    coverage: {
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'src/test/',
        '**/*.d.ts',
        '**/*.config.*'
      ],
      thresholds: {
        global: {
          statements: 80,
          branches: 75,
          functions: 80,
          lines: 80
        },
        // Cobertura m√°s alta para m√≥dulos cr√≠ticos
        'src/features/auth/**': {
          statements: 95,
          branches: 90
        },
        'src/features/emergency/**': {
          statements: 95,
          branches: 95
        }
      }
    }
  }
});
```

## ‚ö†Ô∏è Manejo de Errores M√©dicos

### Error Boundaries Especializados
- **Medical Error Boundary**: Capturar errores en interfaces m√©dicas
- **Fallback UI informativo**: Mostrar informaci√≥n √∫til sin exponer datos
- **Error reporting**: Integraci√≥n con servicio de monitoreo m√©dico
- **Recovery mechanisms**: Recuperaci√≥n autom√°tica cuando sea posible

```typescript
// ‚úÖ Error Boundary m√©dico
class MedicalErrorBoundary extends Component<Props, State> {
  constructor(props: Props) {
    super(props);
    this.state = { hasError: false, errorInfo: null };
  }

  static getDerivedStateFromError(error: Error): State {
    return { hasError: true, errorInfo: error };
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Log cr√≠tico para errores m√©dicos
    logSecurityEvent('critical_medical_error', {
      error: error.message,
      componentStack: errorInfo.componentStack,
      userId: this.props.user?.id,
      patientId: this.props.currentPatient?.id,
      timestamp: new Date().toISOString(),
      severity: 'critical'
    });

    // Reportar a servicio de monitoreo
    if (process.env.NODE_ENV === 'production') {
      reportMedicalError(error, {
        user: this.props.user,
        context: 'medical_interface',
        additionalInfo: errorInfo
      });
    }
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="medical-error-fallback">
          <h2>Error en la aplicaci√≥n m√©dica</h2>
          <p>Se ha producido un error inesperado. El personal t√©cnico ha sido notificado.</p>
          <Button 
            onClick={() => window.location.reload()}
            variant="outline"
          >
            Recargar aplicaci√≥n
          </Button>
          {process.env.NODE_ENV === 'development' && (
            <details className="mt-4">
              <summary>Detalles del error (solo en desarrollo)</summary>
              <pre>{this.state.errorInfo?.message}</pre>
            </details>
          )}
        </div>
      );
    }

    return this.props.children;
  }
}
```

### Logging Estructurado para Auditor√≠a
```typescript
// ‚úÖ Logger m√©dico con niveles de auditor√≠a
interface MedicalLogEvent {
  eventType: 'access' | 'modification' | 'security' | 'emergency' | 'compliance';
  severity: 'info' | 'warning' | 'error' | 'critical';
  userId?: string;
  patientId?: string;
  resourceId?: string;
  action: string;
  metadata?: Record<string, any>;
  timestamp: string;
  ipAddress?: string;
  userAgent?: string;
}

class MedicalLogger {
  logMedicalEvent(event: MedicalLogEvent) {
    const enhancedEvent = {
      ...event,
      timestamp: new Date().toISOString(),
      sessionId: getCurrentSessionId(),
      environment: process.env.NODE_ENV
    };

    // Log local para desarrollo
    console.log(`[MEDICAL] ${event.severity.toUpperCase()}: ${event.action}`, enhancedEvent);

    // En producci√≥n, enviar a servicio de auditor√≠a
    if (process.env.NODE_ENV === 'production') {
      sendToAuditService(enhancedEvent);
    }

    // Para eventos cr√≠ticos, notificar inmediatamente
    if (event.severity === 'critical') {
      notifySecurityTeam(enhancedEvent);
    }
  }
}

export const medicalLogger = new MedicalLogger();
```

## üìà Performance y Escalabilidad M√©dica

### Next.js 15 Optimizations
- **Server Components**: Usar para datos m√©dicos no interactivos
- **Client Components**: Solo cuando necesite interactividad
- **Code splitting**: Lazy loading para dashboards especializados
- **Image optimization**: Optimizar im√°genes m√©dicas (rayos X, etc.)

```typescript
// ‚úÖ Code splitting por rol m√©dico
const DoctorDashboard = dynamic(() => import('@/features/doctor/DoctorDashboard'), {
  loading: () => <DashboardSkeleton role="doctor" />,
  ssr: false // Evitar hidration mismatch con datos sensibles
});

const PatientPortal = dynamic(() => import('@/features/patient/PatientPortal'), {
  loading: () => <PortalSkeleton role="patient" />
});

// ‚úÖ Server component para datos m√©dicos est√°ticos
async function MedicalRecordSummary({ patientId }: { patientId: string }) {
  const record = await getMedicalRecord(patientId); // Server-side fetch
  
  return (
    <div className="medical-summary">
      <h3>Resumen M√©dico</h3>
      {/* Render est√°tico de datos m√©dicos */}
    </div>
  );
}
```

### Database Performance
- **Indexes m√©dicos**: Optimizar consultas frecuentes
- **RLS optimization**: Pol√≠ticas eficientes sin N+1 queries
- **Connection pooling**: Gesti√≥n eficiente de conexiones
- **Query optimization**: Seleccionar solo campos necesarios

```sql
-- ‚úÖ Indexes espec√≠ficos para consultas m√©dicas
CREATE INDEX idx_medical_records_patient_date 
ON medical_records (patient_id, created_at DESC);

CREATE INDEX idx_appointments_doctor_date 
ON appointments (doctor_id, appointment_date) 
WHERE status = 'scheduled';

CREATE INDEX idx_emergency_contacts_patient 
ON emergency_contacts (patient_id) 
WHERE is_active = true;

-- ‚úÖ Funci√≥n RLS optimizada
CREATE OR REPLACE FUNCTION check_medical_access(
  user_id uuid,
  patient_id uuid,
  access_type text
)
RETURNS boolean
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, extensions
AS $$
BEGIN
  -- Cach√© de verificaciones frecuentes
  RETURN EXISTS (
    SELECT 1 FROM user_permissions_cache 
    WHERE user_id = $1 
    AND patient_id = $2 
    AND access_type = $3
    AND expires_at > NOW()
  );
END;
$$;
```

## üöÄ Deployment y CI/CD M√©dico

### Vercel Configuration
```javascript
// vercel.json
{
  "functions": {
    "app/api/**": {
      "maxDuration": 30
    }
  },
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        {
          "key": "X-Content-Type-Options",
          "value": "nosniff"
        },
        {
          "key": "X-Frame-Options",
          "value": "DENY"
        },
        {
          "key": "Strict-Transport-Security",
          "value": "max-age=31536000; includeSubDomains"
        }
      ]
    }
  ]
}
```

### Environment Configuration
```bash
# .env.local.example
# SUPABASE CONFIGURATION (REQUIRED)
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your_anon_key_here
SUPABASE_SERVICE_ROLE_KEY=your_service_role_key_here

# MEDICAL COMPLIANCE
MEDICAL_AUDIT_ENDPOINT=https://audit.yourcompany.com
HIPAA_COMPLIANCE_MODE=true
ENCRYPTION_KEY=your_encryption_key_here

# ENVIRONMENT
NODE_ENV=production
NEXT_PUBLIC_SITE_URL=https://yourmedicalplatform.com

# SECURITY
RATE_LIMIT_ENABLED=true
SESSION_TIMEOUT_MINUTES=30
MAX_LOGIN_ATTEMPTS=3
```

## üìö Documentaci√≥n M√©dica

### Requisitos de Documentaci√≥n
- **Medical API Documentation**: Documentar endpoints m√©dicos con OpenAPI
- **Compliance Documentation**: Documentar medidas de compliance
- **Security Procedures**: Procedimientos de seguridad documentados
- **Emergency Protocols**: Protocolos de emergencia claros

### Comentarios JSDoc M√©dicos
```typescript
/**
 * Creates a new medical record with full audit trail
 * 
 * @param patientId - UUID of the patient (validated against permissions)
 * @param doctorId - UUID of the creating doctor
 * @param recordData - Medical record data (validated with Zod schema)
 * @returns Promise resolving to created medical record
 * 
 * @throws {UnauthorizedError} When doctor lacks permission to create records for patient
 * @throws {ValidationError} When medical data fails validation
 * @throws {ComplianceError} When action violates medical compliance rules
 * 
 * @compliance This function logs all creation attempts for HIPAA audit trail
 * @security Validates permissions before any database operation
 * 
 * @example
 * ```typescript
 * const record = await createMedicalRecord(
 *   'patient-uuid',
 *   'doctor-uuid',
 *   {
 *     diagnosis: 'Hypertension',
 *     treatment: 'ACE inhibitors',
 *     medications: [...],
 *     confidentialityLevel: 'restricted'
 *   }
 * );
 * ```
 */
async function createMedicalRecord(
  patientId: string,
  doctorId: string,
  recordData: MedicalRecordInput
): Promise<MedicalRecord> {
  // Implementation
}
```

## üîÑ Git Workflow M√©dico

### Conventional Commits para Aplicaciones M√©dicas
```bash
# Features m√©dicas
feat(auth): add emergency access override
feat(records): implement medical history encryption
feat(chat): add urgent message prioritization

# Bug fixes cr√≠ticos
fix(security): patch RLS vulnerability in patient data
fix(emergency): resolve contact notification failure
fix(compliance): fix audit trail logging

# Compliance y seguridad
compliance(hipaa): add patient data encryption
security(rls): strengthen medical record policies
audit(logging): enhance security event tracking

# Performance m√©dico
perf(db): optimize medical record queries
perf(ui): lazy load patient dashboard components
```

### Branch Protection Rules
- **main/production**: Requiere review m√©dico + t√©cnico
- **staging**: Testing completo de compliance
- **feature branches**: Nombrar con dominio m√©dico (`feature/medical-records-encryption`)

## ‚úÖ Checklist de Compliance M√©dico

### Antes de cada PR (Pull Request):
- [ ] **Seguridad**
  - [ ] No hay datos m√©dicos hardcodeados
  - [ ] RLS policies verificadas para nuevas tablas
  - [ ] Permisos validados en nuevas funciones
  - [ ] Audit trail implementado para cambios cr√≠ticos
- [ ] **C√≥digo**
  - [ ] Archivo no supera 300 l√≠neas
  - [ ] Tipos TypeScript expl√≠citos para datos m√©dicos
  - [ ] Validaciones Zod para inputs m√©dicos
  - [ ] Error handling robusto implementado
- [ ] **Testing**
  - [ ] Tests unitarios para funciones m√©dicas cr√≠ticas
  - [ ] Tests de seguridad para nuevos permisos
  - [ ] Tests de accessibility para interfaces m√©dicas
  - [ ] Cobertura m√≠nima 80% (95% para m√≥dulos cr√≠ticos)
- [ ] **Performance**
  - [ ] Queries optimizadas sin N+1 problems
  - [ ] Componentes memoizados apropiadamente
  - [ ] Bundle size impacto minimizado
- [ ] **Compliance**
  - [ ] Documentaci√≥n m√©dica actualizada
  - [ ] Variables de entorno configuradas
  - [ ] Migraciones de BD aplicadas y verificadas
  - [ ] Logging de seguridad implementado

### Antes de deployment a producci√≥n:
- [ ] **Medical Compliance Verification**
  - [ ] HIPAA compliance checklist completado
  - [ ] Audit trail funcionando correctamente
  - [ ] Backup y recovery procedures verificados
  - [ ] Security monitoring configurado
- [ ] **Performance Validation**
  - [ ] Load testing en endpoints m√©dicos cr√≠ticos
  - [ ] Database performance verified
  - [ ] CDN configurado para assets m√©dicos
- [ ] **Security Final Check**
  - [ ] Penetration testing completado
  - [ ] SSL/TLS certificados v√°lidos
  - [ ] Environment variables seguras
  - [ ] Rate limiting configurado

---

## üö® RECORDATORIOS CR√çTICOS

> **‚ö†Ô∏è DATOS M√âDICOS SENSIBLES**: Esta aplicaci√≥n maneja informaci√≥n m√©dica protegida. Cada l√≠nea de c√≥digo debe considerar la privacidad y seguridad del paciente.

> **üîí COMPLIANCE OBLIGATORIO**: El incumplimiento de estas reglas puede resultar en violaciones de compliance m√©dico y riesgos legales.

> **üìä AUDIT TRAIL**: Todas las operaciones cr√≠ticas deben ser registradas para auditor√≠a m√©dica.

> **üöÄ PERFORMANCE CR√çTICO**: En emergencias m√©dicas, cada segundo cuenta. El c√≥digo debe ser eficiente y robusto.

---

**Estas reglas son obligatorias para mantener la integridad, seguridad y compliance de la plataforma m√©dica. Cada desarrollador debe familiarizarse y aplicar estas pr√°cticas consistentemente.**