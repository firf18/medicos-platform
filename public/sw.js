// Service Worker for Medical Platform
// Generated by ServiceWorkerService
const CACHE_VERSION = 'v1.0.0';
const CACHE_CONFIGS = [
  {
    name: 'static-assets',
    maxAge: 2592000000, // 30 days
    maxEntries: 100,
    strategy: 'cacheFirst',
    patterns: [
      '/static/**',
      '/_next/static/**',
      '**/*.js',
      '**/*.css',
      '**/*.png',
      '**/*.jpg',
      '**/*.jpeg',
      '**/*.gif',
      '**/*.svg',
      '**/*.ico',
      '**/*.woff',
      '**/*.woff2',
      '**/*.ttf'
    ]
  },
  {
    name: 'api-cache',
    maxAge: 300000, // 5 minutes
    maxEntries: 50,
    strategy: 'staleWhileRevalidate',
    patterns: [
      '/api/auth/check-email',
      '/api/auth/check-phone',
      '/api/auth/check-license',
      '/api/auth/check-document',
      '/api/auth/check-specialty'
    ]
  },
  {
    name: 'medical-data',
    maxAge: 120000, // 2 minutes
    maxEntries: 30,
    strategy: 'networkFirst',
    patterns: [
      '/api/doctors/**',
      '/api/appointments/**',
      '/api/medical-records/**',
      '/api/patients/**'
    ]
  },
  {
    name: 'critical-pages',
    maxAge: 86400000, // 24 hours
    maxEntries: 20,
    strategy: 'staleWhileRevalidate',
    patterns: [
      '/',
      '/auth/login',
      '/auth/register',
      '/dashboard/**',
      '/auth/register/doctor'
    ]
  }
];

// Cache names
const CACHE_NAMES = CACHE_CONFIGS.map(config => `${config.name}-${CACHE_VERSION}`);

// Install event
self.addEventListener('install', (event) => {
  console.log('Service Worker installing...');
  
  event.waitUntil(
    Promise.all([
      // Pre-cache critical assets
      caches.open(`static-assets-${CACHE_VERSION}`).then(cache => {
        return cache.addAll([
          '/',
          '/auth/login',
          '/auth/register',
          '/dashboard',
          '/_next/static/css/app.css',
          '/_next/static/js/app.js'
        ]);
      }),
      // Skip waiting to activate immediately
      self.skipWaiting()
    ])
  );
});

// Activate event
self.addEventListener('activate', (event) => {
  console.log('Service Worker activating...');
  
  event.waitUntil(
    Promise.all([
      // Clean up old caches
      caches.keys().then(cacheNames => {
        return Promise.all(
          cacheNames.map(cacheName => {
            if (!CACHE_NAMES.includes(cacheName)) {
              console.log('Deleting old cache:', cacheName);
              return caches.delete(cacheName);
            }
          })
        );
      }),
      // Take control of all clients
      self.clients.claim()
    ])
  );
});

// Fetch event
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);
  
  // Skip non-GET requests
  if (request.method !== 'GET') {
    return;
  }
  
  // Skip chrome-extension and other non-http requests
  if (!url.protocol.startsWith('http')) {
    return;
  }
  
  // Find matching cache config
  const config = CACHE_CONFIGS.find(cfg => 
    cfg.patterns.some(pattern => matchesPattern(url.pathname, pattern))
  );
  
  if (!config) {
    return;
  }
  
  event.respondWith(handleRequest(request, config));
});

// Handle request based on strategy
async function handleRequest(request, config) {
  const cacheName = `${config.name}-${CACHE_VERSION}`;
  const cache = await caches.open(cacheName);
  
  switch (config.strategy) {
    case 'cacheFirst':
      return cacheFirst(request, cache);
    
    case 'networkFirst':
      return networkFirst(request, cache);
    
    case 'staleWhileRevalidate':
      return staleWhileRevalidate(request, cache);
    
    case 'networkOnly':
      return fetch(request);
    
    case 'cacheOnly':
      return cache.match(request);
    
    default:
      return fetch(request);
  }
}

// Cache first strategy
async function cacheFirst(request, cache) {
  const cachedResponse = await cache.match(request);
  
  if (cachedResponse) {
    // Check if cache is still valid
    const cacheDate = new Date(cachedResponse.headers.get('sw-cache-date') || 0);
    const maxAge = CACHE_CONFIGS.find(cfg => cache.name.includes(cfg.name))?.maxAge || 0;
    
    if (Date.now() - cacheDate.getTime() < maxAge) {
      return cachedResponse;
    }
  }
  
  try {
    const networkResponse = await fetch(request);
    
    if (networkResponse.ok) {
      // Clone response and add cache metadata
      const responseToCache = networkResponse.clone();
      responseToCache.headers.set('sw-cache-date', new Date().toISOString());
      
      // Clean up old entries before adding new one
      await cleanupCache(cache, CACHE_CONFIGS.find(cfg => cache.name.includes(cfg.name)));
      
      cache.put(request, responseToCache);
    }
    
    return networkResponse;
  } catch (error) {
    // Return cached response if network fails
    if (cachedResponse) {
      return cachedResponse;
    }
    throw error;
  }
}

// Network first strategy
async function networkFirst(request, cache) {
  try {
    const networkResponse = await fetch(request);
    
    if (networkResponse.ok) {
      // Clone response and add cache metadata
      const responseToCache = networkResponse.clone();
      responseToCache.headers.set('sw-cache-date', new Date().toISOString());
      
      // Clean up old entries before adding new one
      await cleanupCache(cache, CACHE_CONFIGS.find(cfg => cache.name.includes(cfg.name)));
      
      cache.put(request, responseToCache);
    }
    
    return networkResponse;
  } catch (error) {
    // Fall back to cache
    const cachedResponse = await cache.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }
    throw error;
  }
}

// Stale while revalidate strategy
async function staleWhileRevalidate(request, cache) {
  const cachedResponse = await cache.match(request);
  
  // Always try to fetch from network
  const networkResponsePromise = fetch(request).then(response => {
    if (response.ok) {
      const responseToCache = response.clone();
      responseToCache.headers.set('sw-cache-date', new Date().toISOString());
      
      // Clean up old entries before adding new one
      cleanupCache(cache, CACHE_CONFIGS.find(cfg => cache.name.includes(cfg.name)));
      
      cache.put(request, responseToCache);
    }
    return response;
  }).catch(() => null);
  
  // Return cached response immediately if available
  if (cachedResponse) {
    return cachedResponse;
  }
  
  // Otherwise wait for network response
  return networkResponsePromise || new Response('Network error', { status: 503 });
}

// Clean up cache based on max entries and age
async function cleanupCache(cache, config) {
  if (!config) return;
  
  const keys = await cache.keys();
  
  // Remove entries older than maxAge
  const now = Date.now();
  const expiredKeys = [];
  
  for (const key of keys) {
    const response = await cache.match(key);
    if (response) {
      const cacheDate = new Date(response.headers.get('sw-cache-date') || 0);
      if (now - cacheDate.getTime() > config.maxAge) {
        expiredKeys.push(key);
      }
    }
  }
  
  // Remove expired entries
  await Promise.all(expiredKeys.map(key => cache.delete(key)));
  
  // Remove excess entries if over maxEntries
  const remainingKeys = await cache.keys();
  if (remainingKeys.length > config.maxEntries) {
    const keysToRemove = remainingKeys.slice(0, remainingKeys.length - config.maxEntries);
    await Promise.all(keysToRemove.map(key => cache.delete(key)));
  }
}

// Check if URL matches pattern
function matchesPattern(url, pattern) {
  if (pattern.includes('**')) {
    const regex = new RegExp(pattern.replace(/\*\*/g, '.*'));
    return regex.test(url);
  }
  
  if (pattern.includes('*')) {
    const regex = new RegExp(pattern.replace(/\*/g, '[^/]*'));
    return regex.test(url);
  }
  
  return url === pattern;
}

// Background sync for offline actions
self.addEventListener('sync', (event) => {
  if (event.tag === 'background-sync') {
    event.waitUntil(handleBackgroundSync());
  }
});

// Handle background sync
async function handleBackgroundSync() {
  try {
    // Get pending offline actions from IndexedDB
    const pendingActions = await getPendingActions();
    
    for (const action of pendingActions) {
      try {
        await syncAction(action);
        await removePendingAction(action.id);
      } catch (error) {
        console.error('Failed to sync action:', action, error);
      }
    }
  } catch (error) {
    console.error('Background sync failed:', error);
  }
}

// Push notification handling
self.addEventListener('push', (event) => {
  if (event.data) {
    const data = event.data.json();
    
    const options = {
      body: data.body,
      icon: '/icons/icon-192x192.png',
      badge: '/icons/badge-72x72.png',
      tag: data.tag || 'medical-notification',
      data: data.data,
      actions: data.actions || []
    };
    
    event.waitUntil(
      self.registration.showNotification(data.title, options)
    );
  }
});

// Notification click handling
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  
  if (event.action === 'view') {
    event.waitUntil(
      clients.openWindow(event.notification.data.url || '/')
    );
  }
});

// Message handling from main thread
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
  
  if (event.data && event.data.type === 'GET_CACHE_STATS') {
    getCacheStats().then(stats => {
      event.ports[0].postMessage(stats);
    });
  }
});

// Get cache statistics
async function getCacheStats() {
  const stats = [];
  
  for (const config of CACHE_CONFIGS) {
    const cacheName = `${config.name}-${CACHE_VERSION}`;
    const cache = await caches.open(cacheName);
    const keys = await cache.keys();
    
    stats.push({
      cacheName: config.name,
      entries: keys.length,
      maxEntries: config.maxEntries,
      strategy: config.strategy,
      maxAge: config.maxAge
    });
  }
  
  return stats;
}

// Placeholder functions for IndexedDB operations
async function getPendingActions() {
  // Implementation would use IndexedDB to get pending offline actions
  return [];
}

async function syncAction(action) {
  // Implementation would sync the action with the server
  console.log('Syncing action:', action);
}

async function removePendingAction(actionId) {
  // Implementation would remove the action from IndexedDB
  console.log('Removing pending action:', actionId);
}
