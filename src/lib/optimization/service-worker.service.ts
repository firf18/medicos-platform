/**
 * Service Worker Optimization Service
 * @fileoverview Service for implementing offline caching and performance optimization
 * @compliance HIPAA-compliant offline caching with security considerations
 */

/**
 * Cache configuration
 */
interface CacheConfig {
  name: string;
  maxAge: number; // in milliseconds
  maxEntries: number;
  strategy: 'cacheFirst' | 'networkFirst' | 'staleWhileRevalidate' | 'networkOnly' | 'cacheOnly';
  patterns: string[];
}

/**
 * Cache statistics
 */
interface CacheStats {
  cacheName: string;
  hits: number;
  misses: number;
  size: number;
  lastUpdated: string;
}

/**
 * Service Worker Optimization Service
 */
export class ServiceWorkerService {
  private static readonly CACHE_VERSION = 'v1.0.0';
  private static readonly CACHE_CONFIGS: CacheConfig[] = [
    {
      name: 'static-assets',
      maxAge: 30 * 24 * 60 * 60 * 1000, // 30 days
      maxEntries: 100,
      strategy: 'cacheFirst',
      patterns: [
        '/static/**',
        '/_next/static/**',
        '**/*.js',
        '**/*.css',
        '**/*.png',
        '**/*.jpg',
        '**/*.jpeg',
        '**/*.gif',
        '**/*.svg',
        '**/*.ico',
        '**/*.woff',
        '**/*.woff2',
        '**/*.ttf'
      ]
    },
    {
      name: 'api-cache',
      maxAge: 5 * 60 * 1000, // 5 minutes
      maxEntries: 50,
      strategy: 'staleWhileRevalidate',
      patterns: [
        '/api/auth/check-email',
        '/api/auth/check-phone',
        '/api/auth/check-license',
        '/api/auth/check-document',
        '/api/auth/check-specialty'
      ]
    },
    {
      name: 'medical-data',
      maxAge: 2 * 60 * 1000, // 2 minutes
      maxEntries: 30,
      strategy: 'networkFirst',
      patterns: [
        '/api/doctors/**',
        '/api/appointments/**',
        '/api/medical-records/**',
        '/api/patients/**'
      ]
    },
    {
      name: 'critical-pages',
      maxAge: 24 * 60 * 60 * 1000, // 24 hours
      maxEntries: 20,
      strategy: 'staleWhileRevalidate',
      patterns: [
        '/',
        '/auth/login',
        '/auth/register',
        '/dashboard/**',
        '/auth/register/doctor'
      ]
    }
  ];

  /**
   * Generate service worker code
   */
  static generateServiceWorker(): string {
    return `
// Service Worker for Medical Platform
// Generated by ServiceWorkerService
const CACHE_VERSION = '${this.CACHE_VERSION}';
const CACHE_CONFIGS = ${JSON.stringify(this.CACHE_CONFIGS, null, 2)};

// Cache names
const CACHE_NAMES = CACHE_CONFIGS.map(config => \`\${config.name}-\${CACHE_VERSION}\`);

// Install event
self.addEventListener('install', (event) => {
  console.log('Service Worker installing...');
  
  event.waitUntil(
    Promise.all([
      // Pre-cache critical assets
      caches.open(\`static-assets-\${CACHE_VERSION}\`).then(cache => {
        return cache.addAll([
          '/',
          '/auth/login',
          '/auth/register',
          '/dashboard',
          '/_next/static/css/app.css',
          '/_next/static/js/app.js'
        ]);
      }),
      // Skip waiting to activate immediately
      self.skipWaiting()
    ])
  );
});

// Activate event
self.addEventListener('activate', (event) => {
  console.log('Service Worker activating...');
  
  event.waitUntil(
    Promise.all([
      // Clean up old caches
      caches.keys().then(cacheNames => {
        return Promise.all(
          cacheNames.map(cacheName => {
            if (!CACHE_NAMES.includes(cacheName)) {
              console.log('Deleting old cache:', cacheName);
              return caches.delete(cacheName);
            }
          })
        );
      }),
      // Take control of all clients
      self.clients.claim()
    ])
  );
});

// Fetch event
self.addEventListener('fetch', (event) => {
  const { request } = event;
  const url = new URL(request.url);
  
  // Skip non-GET requests
  if (request.method !== 'GET') {
    return;
  }
  
  // Skip chrome-extension and other non-http requests
  if (!url.protocol.startsWith('http')) {
    return;
  }
  
  // Find matching cache config
  const config = CACHE_CONFIGS.find(cfg => 
    cfg.patterns.some(pattern => this.matchesPattern(url.pathname, pattern))
  );
  
  if (!config) {
    return;
  }
  
  event.respondWith(this.handleRequest(request, config));
});

// Handle request based on strategy
async function handleRequest(request, config) {
  const cacheName = \`\${config.name}-\${CACHE_VERSION}\`;
  const cache = await caches.open(cacheName);
  
  switch (config.strategy) {
    case 'cacheFirst':
      return this.cacheFirst(request, cache);
    
    case 'networkFirst':
      return this.networkFirst(request, cache);
    
    case 'staleWhileRevalidate':
      return this.staleWhileRevalidate(request, cache);
    
    case 'networkOnly':
      return fetch(request);
    
    case 'cacheOnly':
      return cache.match(request);
    
    default:
      return fetch(request);
  }
}

// Cache first strategy
async function cacheFirst(request, cache) {
  const cachedResponse = await cache.match(request);
  
  if (cachedResponse) {
    // Check if cache is still valid
    const cacheDate = new Date(cachedResponse.headers.get('sw-cache-date') || 0);
    const maxAge = CACHE_CONFIGS.find(cfg => cache.name.includes(cfg.name))?.maxAge || 0;
    
    if (Date.now() - cacheDate.getTime() < maxAge) {
      return cachedResponse;
    }
  }
  
  try {
    const networkResponse = await fetch(request);
    
    if (networkResponse.ok) {
      // Clone response and add cache metadata
      const responseToCache = networkResponse.clone();
      responseToCache.headers.set('sw-cache-date', new Date().toISOString());
      
      // Clean up old entries before adding new one
      await this.cleanupCache(cache, CACHE_CONFIGS.find(cfg => cache.name.includes(cfg.name)));
      
      cache.put(request, responseToCache);
    }
    
    return networkResponse;
  } catch (error) {
    // Return cached response if network fails
    if (cachedResponse) {
      return cachedResponse;
    }
    throw error;
  }
}

// Network first strategy
async function networkFirst(request, cache) {
  try {
    const networkResponse = await fetch(request);
    
    if (networkResponse.ok) {
      // Clone response and add cache metadata
      const responseToCache = networkResponse.clone();
      responseToCache.headers.set('sw-cache-date', new Date().toISOString());
      
      // Clean up old entries before adding new one
      await this.cleanupCache(cache, CACHE_CONFIGS.find(cfg => cache.name.includes(cfg.name)));
      
      cache.put(request, responseToCache);
    }
    
    return networkResponse;
  } catch (error) {
    // Fall back to cache
    const cachedResponse = await cache.match(request);
    if (cachedResponse) {
      return cachedResponse;
    }
    throw error;
  }
}

// Stale while revalidate strategy
async function staleWhileRevalidate(request, cache) {
  const cachedResponse = await cache.match(request);
  
  // Always try to fetch from network
  const networkResponsePromise = fetch(request).then(response => {
    if (response.ok) {
      const responseToCache = response.clone();
      responseToCache.headers.set('sw-cache-date', new Date().toISOString());
      
      // Clean up old entries before adding new one
      this.cleanupCache(cache, CACHE_CONFIGS.find(cfg => cache.name.includes(cfg.name)));
      
      cache.put(request, responseToCache);
    }
    return response;
  }).catch(() => null);
  
  // Return cached response immediately if available
  if (cachedResponse) {
    return cachedResponse;
  }
  
  // Otherwise wait for network response
  return networkResponsePromise || new Response('Network error', { status: 503 });
}

// Clean up cache based on max entries and age
async function cleanupCache(cache, config) {
  if (!config) return;
  
  const keys = await cache.keys();
  
  // Remove entries older than maxAge
  const now = Date.now();
  const expiredKeys = [];
  
  for (const key of keys) {
    const response = await cache.match(key);
    if (response) {
      const cacheDate = new Date(response.headers.get('sw-cache-date') || 0);
      if (now - cacheDate.getTime() > config.maxAge) {
        expiredKeys.push(key);
      }
    }
  }
  
  // Remove expired entries
  await Promise.all(expiredKeys.map(key => cache.delete(key)));
  
  // Remove excess entries if over maxEntries
  const remainingKeys = await cache.keys();
  if (remainingKeys.length > config.maxEntries) {
    const keysToRemove = remainingKeys.slice(0, remainingKeys.length - config.maxEntries);
    await Promise.all(keysToRemove.map(key => cache.delete(key)));
  }
}

// Check if URL matches pattern
function matchesPattern(url, pattern) {
  if (pattern.includes('**')) {
    const regex = new RegExp(pattern.replace(/\\*\\*/g, '.*'));
    return regex.test(url);
  }
  
  if (pattern.includes('*')) {
    const regex = new RegExp(pattern.replace(/\\*/g, '[^/]*'));
    return regex.test(url);
  }
  
  return url === pattern;
}

// Background sync for offline actions
self.addEventListener('sync', (event) => {
  if (event.tag === 'background-sync') {
    event.waitUntil(this.handleBackgroundSync());
  }
});

// Handle background sync
async function handleBackgroundSync() {
  try {
    // Get pending offline actions from IndexedDB
    const pendingActions = await this.getPendingActions();
    
    for (const action of pendingActions) {
      try {
        await this.syncAction(action);
        await this.removePendingAction(action.id);
      } catch (error) {
        console.error('Failed to sync action:', action, error);
      }
    }
  } catch (error) {
    console.error('Background sync failed:', error);
  }
}

// Push notification handling
self.addEventListener('push', (event) => {
  if (event.data) {
    const data = event.data.json();
    
    const options = {
      body: data.body,
      icon: '/icons/icon-192x192.png',
      badge: '/icons/badge-72x72.png',
      tag: data.tag || 'medical-notification',
      data: data.data,
      actions: data.actions || []
    };
    
    event.waitUntil(
      self.registration.showNotification(data.title, options)
    );
  }
});

// Notification click handling
self.addEventListener('notificationclick', (event) => {
  event.notification.close();
  
  if (event.action === 'view') {
    event.waitUntil(
      clients.openWindow(event.notification.data.url || '/')
    );
  }
});

// Message handling from main thread
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }
  
  if (event.data && event.data.type === 'GET_CACHE_STATS') {
    this.getCacheStats().then(stats => {
      event.ports[0].postMessage(stats);
    });
  }
});

// Get cache statistics
async function getCacheStats() {
  const stats = [];
  
  for (const config of CACHE_CONFIGS) {
    const cacheName = \`\${config.name}-\${CACHE_VERSION}\`;
    const cache = await caches.open(cacheName);
    const keys = await cache.keys();
    
    stats.push({
      cacheName: config.name,
      entries: keys.length,
      maxEntries: config.maxEntries,
      strategy: config.strategy,
      maxAge: config.maxAge
    });
  }
  
  return stats;
}

// Placeholder functions for IndexedDB operations
async function getPendingActions() {
  // Implementation would use IndexedDB to get pending offline actions
  return [];
}

async function syncAction(action) {
  // Implementation would sync the action with the server
  console.log('Syncing action:', action);
}

async function removePendingAction(actionId) {
  // Implementation would remove the action from IndexedDB
  console.log('Removing pending action:', actionId);
}
`;
  }

  /**
   * Register service worker
   */
  static async registerServiceWorker(): Promise<boolean> {
    if (typeof window === 'undefined' || !('serviceWorker' in navigator)) {
      return false;
    }

    try {
      const registration = await navigator.serviceWorker.register('/sw.js', {
        scope: '/'
      });

      console.log('Service Worker registered successfully:', registration);

      // Handle updates
      registration.addEventListener('updatefound', () => {
        const newWorker = registration.installing;
        if (newWorker) {
          newWorker.addEventListener('statechange', () => {
            if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
              // New service worker is available
              this.showUpdateNotification();
            }
          });
        }
      });

      return true;
    } catch (error) {
      console.error('Service Worker registration failed:', error);
      return false;
    }
  }

  /**
   * Unregister service worker
   */
  static async unregisterServiceWorker(): Promise<boolean> {
    if (typeof window === 'undefined' || !('serviceWorker' in navigator)) {
      return false;
    }

    try {
      const registrations = await navigator.serviceWorker.getRegistrations();
      await Promise.all(registrations.map(registration => registration.unregister()));
      console.log('Service Worker unregistered successfully');
      return true;
    } catch (error) {
      console.error('Service Worker unregistration failed:', error);
      return false;
    }
  }

  /**
   * Get cache statistics
   */
  static async getCacheStats(): Promise<CacheStats[]> {
    if (typeof window === 'undefined' || !('serviceWorker' in navigator)) {
      return [];
    }

    try {
      const registration = await navigator.serviceWorker.ready;
      const stats: CacheStats[] = [];

      for (const config of this.CACHE_CONFIGS) {
        const cacheName = `${config.name}-${this.CACHE_VERSION}`;
        const cache = await caches.open(cacheName);
        const keys = await cache.keys();

        stats.push({
          cacheName: config.name,
          hits: 0, // Would be tracked by service worker
          misses: 0, // Would be tracked by service worker
          size: keys.length,
          lastUpdated: new Date().toISOString()
        });
      }

      return stats;
    } catch (error) {
      console.error('Failed to get cache stats:', error);
      return [];
    }
  }

  /**
   * Clear all caches
   */
  static async clearAllCaches(): Promise<void> {
    if (typeof window === 'undefined' || !('caches' in window)) {
      return;
    }

    try {
      const cacheNames = await caches.keys();
      await Promise.all(cacheNames.map(name => caches.delete(name)));
      console.log('All caches cleared');
    } catch (error) {
      console.error('Failed to clear caches:', error);
    }
  }

  /**
   * Preload critical resources
   */
  static async preloadCriticalResources(): Promise<void> {
    if (typeof window === 'undefined' || !('serviceWorker' in navigator)) {
      return;
    }

    try {
      const criticalResources = [
        '/',
        '/auth/login',
        '/auth/register',
        '/dashboard',
        '/_next/static/css/app.css',
        '/_next/static/js/app.js'
      ];

      const cache = await caches.open(`static-assets-${this.CACHE_VERSION}`);
      await cache.addAll(criticalResources);
      
      console.log('Critical resources preloaded');
    } catch (error) {
      console.error('Failed to preload critical resources:', error);
    }
  }

  /**
   * Show update notification
   */
  private static showUpdateNotification(): void {
    if (typeof window === 'undefined') return;

    // Create a simple notification
    const notification = document.createElement('div');
    notification.className = 'fixed top-4 right-4 bg-blue-600 text-white p-4 rounded shadow-lg z-50';
    notification.innerHTML = `
      <div class="flex items-center">
        <span class="mr-2">🔄</span>
        <span>Nueva versión disponible</span>
        <button onclick="window.location.reload()" class="ml-4 px-2 py-1 bg-blue-700 rounded text-sm">
          Actualizar
        </button>
      </div>
    `;

    document.body.appendChild(notification);

    // Auto-remove after 10 seconds
    setTimeout(() => {
      if (notification.parentNode) {
        notification.parentNode.removeChild(notification);
      }
    }, 10000);
  }
}

/**
 * Service Worker utilities for the main thread
 */
export class ServiceWorkerUtils {
  /**
   * Send message to service worker
   */
  static async sendMessageToSW(message: any): Promise<any> {
    if (typeof window === 'undefined' || !('serviceWorker' in navigator)) {
      return null;
    }

    try {
      const registration = await navigator.serviceWorker.ready;
      const messageChannel = new MessageChannel();
      
      return new Promise((resolve) => {
        messageChannel.port1.onmessage = (event) => {
          resolve(event.data);
        };
        
        registration.active?.postMessage(message, [messageChannel.port2]);
      });
    } catch (error) {
      console.error('Failed to send message to service worker:', error);
      return null;
    }
  }

  /**
   * Check if service worker is ready
   */
  static async isServiceWorkerReady(): Promise<boolean> {
    if (typeof window === 'undefined' || !('serviceWorker' in navigator)) {
      return false;
    }

    try {
      const registration = await navigator.serviceWorker.ready;
      return !!registration.active;
    } catch (error) {
      return false;
    }
  }

  /**
   * Get service worker status
   */
  static async getServiceWorkerStatus(): Promise<{
    isSupported: boolean;
    isRegistered: boolean;
    isActive: boolean;
    registration?: ServiceWorkerRegistration;
  }> {
    const isSupported = typeof window !== 'undefined' && 'serviceWorker' in navigator;
    
    if (!isSupported) {
      return { isSupported: false, isRegistered: false, isActive: false };
    }

    try {
      const registration = await navigator.serviceWorker.getRegistration();
      const isRegistered = !!registration;
      const isActive = !!registration?.active;

      return {
        isSupported,
        isRegistered,
        isActive,
        registration
      };
    } catch (error) {
      return { isSupported, isRegistered: false, isActive: false };
    }
  }
}
